<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This is my technical blog. For taking learning notes and sharing my experience."><meta name=author content="Hans Tsai"><link href=https://hans-tsai.github.io/hans_blog/version_control/git/ rel=canonical><link href=../../programming_language/nodejs/ rel=prev><link href=../../mkdocs_info/mkdocs/ rel=next><link rel=icon href=../../assets/favicon.png><meta name=generator content="mkdocs-1.4.3, mkdocs-material-9.1.18"><title>Git - Hans' blog</title><link rel=stylesheet href=../../assets/stylesheets/main.eebd395e.min.css><link rel=stylesheet href=../../assets/stylesheets/palette.ecc896b0.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><script>"undefined"!=typeof __md_analytics&&__md_analytics()</script><link rel=stylesheet href=../../assets/stylesheets/custom.f7ec4df2.min.css></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=cyan data-md-color-accent=cyan> <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#git-learn class=md-skip> Skip to content </a> </div> <div data-md-component=announce> <aside class=md-banner> <div class="md-banner__inner md-grid md-typeset"> <button class="md-banner__button md-icon" aria-label="Don't show this again"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> For updates follow <strong>@squidfunk</strong> on <a rel=me href=https://fosstodon.org/@squidfunk> <span class="twemoji mastodon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M433 179.11c0-97.2-63.71-125.7-63.71-125.7-62.52-28.7-228.56-28.4-290.48 0 0 0-63.72 28.5-63.72 125.7 0 115.7-6.6 259.4 105.63 289.1 40.51 10.7 75.32 13 103.33 11.4 50.81-2.8 79.32-18.1 79.32-18.1l-1.7-36.9s-36.31 11.4-77.12 10.1c-40.41-1.4-83-4.4-89.63-54a102.54 102.54 0 0 1-.9-13.9c85.63 20.9 158.65 9.1 178.75 6.7 56.12-6.7 105-41.3 111.23-72.9 9.8-49.8 9-121.5 9-121.5zm-75.12 125.2h-46.63v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.33V197c0-58.5-64-56.6-64-6.9v114.2H90.19c0-122.1-5.2-147.9 18.41-175 25.9-28.9 79.82-30.8 103.83 6.1l11.6 19.5 11.6-19.5c24.11-37.1 78.12-34.8 103.83-6.1 23.71 27.3 18.4 53 18.4 175z"/></svg> </span> <strong>Fosstodon</strong> </a> and <a href=https://twitter.com/squidfunk> <span class="twemoji twitter"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><!-- Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg> </span> <strong>Twitter</strong> </a> </div> <script>var content,el=document.querySelector("[data-md-component=announce]");el&&(content=el.querySelector(".md-typeset"),__md_hash(content.innerHTML)===__md_get("__announce")&&(el.hidden=!0))</script> </aside> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../.. title="Hans' blog" class="md-header__button md-logo" aria-label="Hans' blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 89 89"> <path d=M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z /> <path d=M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z style="fill-opacity: 0.5"/> <path d=M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z /> <path d=M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z style="fill-opacity: 0.25"/> </svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Hans' blog </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> Git </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=cyan data-md-color-accent=cyan aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=cyan data-md-color-accent=cyan aria-label="Switch to light mode" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg> </label> </form> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <a href=javascript:void(0) class="md-search__icon md-icon" title=Share aria-label=Share data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/Hans-Tsai/hans_blog title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> hans-tsai/hans_blog </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=Tabs data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../../programming_language/nodejs/ class=md-tabs__link> Programming language </a> </li> <li class=md-tabs__item> <a href=./ class="md-tabs__link md-tabs__link--active"> Version Control </a> </li> <li class=md-tabs__item> <a href=../../mkdocs_info/mkdocs/ class=md-tabs__link> MkDocs Info </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../.. title="Hans' blog" class="md-nav__button md-logo" aria-label="Hans' blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 89 89"> <path d=M3.136,17.387l0,42.932l42.932,21.467l-42.932,-64.399Z /> <path d=M21.91,8l42.933,64.398l-18.775,9.388l-42.932,-64.399l18.774,-9.387Z style="fill-opacity: 0.5"/> <path d=M67.535,17.387l-27.262,18.156l21.878,32.818l5.384,2.691l0,-53.665Z /> <path d=M67.535,17.387l0,53.666l18.774,-9.388l0,-53.665l-18.774,9.387Z style="fill-opacity: 0.25"/> </svg> </a> Hans' blog </label> <div class=md-nav__source> <a href=https://github.com/Hans-Tsai/hans_blog title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> hans-tsai/hans_blog </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../.. class=md-nav__link> Home </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex=0> Programming language <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=false> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Programming language </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../programming_language/nodejs/ class=md-nav__link> Node.js </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3 checked> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> Version Control <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=true> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Version Control </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Git <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> Git </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#git class=md-nav__link> 自主學習 Git 的觀念和指令後做的統整 &amp; 學習筆記 </a> <nav class=md-nav aria-label="自主學習 Git 的觀念和指令後做的統整 & 學習筆記"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 安裝方式 </a> <nav class=md-nav aria-label=安裝方式> <ul class=md-nav__list> <li class=md-nav__item> <a href=#windows class=md-nav__link> Windows系統 </a> </li> <li class=md-nav__item> <a href=#macos class=md-nav__link> MacOS系統 </a> </li> <li class=md-nav__item> <a href=#linux class=md-nav__link> Linux系統 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#git_1 class=md-nav__link> 設定Git </a> </li> <li class=md-nav__item> <a href=#git_2 class=md-nav__link> Git 基礎常用指令 </a> <nav class=md-nav aria-label="Git 基礎常用指令"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git_3 class=md-nav__link> 初始化該目錄,主要目的是讓Git開始對這個目錄進行版本控制 </a> </li> <li class=md-nav__item> <a href=#git_4 class=md-nav__link> 把這個檔案交給Git來控管 </a> </li> <li class=md-nav__item> <a href=#staging-area class=md-nav__link> 把暫存區(staging area)的檔案提交到倉庫存檔 </a> </li> <li class=md-nav__item> <a href=#git_5 class=md-nav__link> 想檢視Git紀錄 </a> </li> <li class=md-nav__item> <a href=#git_6 class=md-nav__link> 刪除Git檔案 </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 變更檔名 </a> </li> <li class=md-nav__item> <a href=#commit class=md-nav__link> 修改Commit紀錄 </a> </li> <li class=md-nav__item> <a href=#gitgit-server-gitignore class=md-nav__link> 如果有特定檔案不想放在Git裡面一起備份或是上傳到Git Server的話,例如:資料庫密碼,雲端伺服器的金鑰...可以加入 .gitignore中 </a> </li> <li class=md-nav__item> <a href=#commit_1 class=md-nav__link> 檢視特定檔案的commit紀錄 </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 想要知道某個檔案的某一行是誰寫的 </a> </li> <li class=md-nav__item> <a href=#working-directory-rm class=md-nav__link> 在工作目錄(working directory)想要復原不小心透過 rm 指令刪除的檔案 </a> </li> <li class=md-nav__item> <a href=#commit_2 class=md-nav__link> 如果想重新編輯剛才的commit </a> </li> <li class=md-nav__item> <a href=#tagcommmit class=md-nav__link> 新增Tag物件到Commmit物件 </a> </li> <li class=md-nav__item> <a href=#branch class=md-nav__link> 分支(branch)操作 </a> </li> <li class=md-nav__item> <a href=#commit_3 class=md-nav__link> 該如何回復到上一次commit紀錄的狀態? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 觀念介紹 </a> <nav class=md-nav aria-label=觀念介紹> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git_7 class=md-nav__link> Git 其實是一種分散式的版本控制系統 </a> </li> <li class=md-nav__item> <a href=#git_8 class=md-nav__link> Git 的優點 </a> </li> <li class=md-nav__item> <a href=#git-snapshot class=md-nav__link> Git 是用快照(snapshot)在做版本控制的 </a> </li> <li class=md-nav__item> <a href=#git-blobtreecommittag class=md-nav__link> Git 的四大物件(Blob,Tree,Commit,Tag)觀念介紹 </a> </li> <li class=md-nav__item> <a href=#git-count-objects class=md-nav__link> $ git count-objects: 可以檢視目前有多少物件和用掉多少儲存空間 </a> </li> <li class=md-nav__item> <a href=#git_9 class=md-nav__link> 在使用Git時,指令要在正確的目錄下才能正常運作 </a> </li> <li class=md-nav__item> <a href=#gitstaging-areaindex class=md-nav__link> 在Git術語中,暫存區(staging area)=索引(index) </a> </li> <li class=md-nav__item> <a href=#git-working-directorystaging-arearepository class=md-nav__link> Git 世界裡的的三大區域---工作目錄(working directory),暫存區(staging area),儲存庫(repository) </a> </li> <li class=md-nav__item> <a href=#git-add-git-commit class=md-nav__link> 為什麼每次都要先$ git add 再 $ git commit </a> </li> <li class=md-nav__item> <a href=#gitid-sha-1 class=md-nav__link> Git物件的id是怎麼計算出來的? (SHA-1演算法) </a> </li> <li class=md-nav__item> <a href=#head class=md-nav__link> HEAD是什麼? </a> </li> <li class=md-nav__item> <a href=#orig_head class=md-nav__link> ORIG_HEAD是什麼? </a> </li> <li class=md-nav__item> <a href=#branch_1 class=md-nav__link> 分支(branch)是什麼? </a> </li> <li class=md-nav__item> <a href=#detached-head class=md-nav__link> Detached HEAD (斷頭) 是什麼? </a> </li> <li class=md-nav__item> <a href=#tag class=md-nav__link> Tag (標籤) 是什麼? </a> </li> <li class=md-nav__item> <a href=#git-git-gc class=md-nav__link> Git的資源回收機制($ git gc)是怎麼運作的呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 觀念釐清 </a> <nav class=md-nav aria-label=觀念釐清> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git_10 class=md-nav__link> Git無法控管 空目錄/ </a> </li> <li class=md-nav__item> <a href=#git-rm-cached-vs-gitignore class=md-nav__link> $ git rm --cached V.S. .gitignore 比較 </a> </li> <li class=md-nav__item> <a href=#git-git class=md-nav__link> 在專案中的整個.git/ 目錄是Git版控的核心檔案 </a> </li> <li class=md-nav__item> <a href=#git-reset-commit class=md-nav__link> $ git reset 是用來"前往"到指定的Commit物件上的 </a> </li> <li class=md-nav__item> <a href=#gitblobtreecommittag class=md-nav__link> Git四大物件(Blob,Tree,Commit,Tag)彼此之間其實是平行關係 </a> </li> <li class=md-nav__item> <a href=#gitsnapshot class=md-nav__link> Git其實不是在做差異備份,而是在為當時的專案建立快照(snapshot) </a> </li> <li class=md-nav__item> <a href=#catdogdogcat class=md-nav__link> 把cat分支合併到dog分支&amp;把dog分支合併到cat分支有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 合併分支其實不是真的在合併分支! </a> </li> <li class=md-nav__item> <a href=#resetrebaserevert class=md-nav__link> Reset、Rebase、Revert 三個指令有什麼差別? </a> </li> <li class=md-nav__item> <a href=#tagbranch class=md-nav__link> 標籤(Tag)跟分支(branch)有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#unreachable-dangling class=md-nav__link> Unreachable物件 &amp; Dangling物件 有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#git-log-git-reflog class=md-nav__link> $ git log &amp; git reflog 有什麼不同呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 實戰情境題 </a> <nav class=md-nav aria-label=實戰情境題> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git-add class=md-nav__link> 如果在git add之後又修改了那個檔案的內容呢? </a> </li> <li class=md-nav__item> <a href=#git-reset-hard class=md-nav__link> 如果不小心使用$ git reset --hard 模式,能救回來嗎? </a> </li> <li class=md-nav__item> <a href=#commit_4 class=md-nav__link> 如果這次只想commit一個檔案中的部份內容的話,該怎麼做呢? </a> </li> <li class=md-nav__item> <a href=#branch_2 class=md-nav__link> 如果修改專案的某些檔案到一半,卻不小心先切換到別的分支(branch),該怎麼辦? </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> 如果不小心把還沒合併的分支刪掉了,該怎麼挽救? </a> </li> <li class=md-nav__item> <a href=#commitbranch class=md-nav__link> 如果想從過去的某次commit紀錄再長一個新的分支(branch)出來,該如何做呢? </a> </li> <li class=md-nav__item> <a href=#both-modified class=md-nav__link> 當兩個分支都編輯了同一個檔案(both modified 狀態),造成合併分支時發生衝突了,該怎麼解決呢? </a> </li> <li class=md-nav__item> <a href=#_9 class=md-nav__link> 目前的工作做到一半,如果要臨時切換到別的任務,該怎麼做呢? </a> </li> <li class=md-nav__item> <a href=#exgit class=md-nav__link> 如果不小心將機敏資料(ex:帳號、密碼)放在Git裡,想把它刪掉,該怎麼做呢? </a> </li> <li class=md-nav__item> <a href=#commit_5 class=md-nav__link> 可以只取用某個分支的其中某幾個commit嗎? </a> </li> <li class=md-nav__item> <a href=#git_11 class=md-nav__link> 如何把一個檔案從Git版控中真正的移除掉呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#-github class=md-nav__link> 遠端共同協作篇---以 GitHub 為例 </a> <nav class=md-nav aria-label="遠端共同協作篇---以 GitHub 為例"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#github class=md-nav__link> GitHub 基礎使用操作說明 </a> </li> <li class=md-nav__item> <a href=#github-repositoryrepositorygithub class=md-nav__link> 新建一個GitHub repository,並推送本地端repository到GitHub上 </a> </li> <li class=md-nav__item> <a href=#repositorypull class=md-nav__link> 從遠端repository利用Pull下載並更新 </a> </li> <li class=md-nav__item> <a href=#pushrepository class=md-nav__link> 為什麼有時候會推送(Push)不上去遠端repository呢? </a> </li> <li class=md-nav__item> <a href=#repository class=md-nav__link> 從伺服器上複製遠端repository下來 </a> </li> <li class=md-nav__item> <a href=#clone-pull class=md-nav__link> Clone(複製) 和 Pull(拉下來更新) 有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#pull-request class=md-nav__link> 利用Pull Request來跟其它開發者的開源專案做互動 </a> </li> <li class=md-nav__item> <a href=#fork class=md-nav__link> 如何跟上當初Fork的專案的進度呢? </a> </li> <li class=md-nav__item> <a href=#_10 class=md-nav__link> 如何刪除遠端分支呢? </a> </li> <li class=md-nav__item> <a href=#git-push-f-pushrepository class=md-nav__link> 什麼時機適合用$ git push -f 來強制推送(Push)上去到遠端repository呢? </a> </li> <li class=md-nav__item> <a href=#patchrepository class=md-nav__link> 如何透過更新檔(Patch)來更新本機端的repository的內容呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#git_12 class=md-nav__link> Git 常見的團隊工作流程 &amp; 規範 </a> <nav class=md-nav aria-label="Git 常見的團隊工作流程 & 規範"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git-flow class=md-nav__link> Git Flow介紹 </a> </li> <li class=md-nav__item> <a href=#github-flow class=md-nav__link> GitHub Flow介紹 </a> </li> <li class=md-nav__item> <a href=#gitlab-flow class=md-nav__link> GitLab Flow介紹 </a> </li> <li class=md-nav__item> <a href=#git-flow-github-flow-gitlab-flow class=md-nav__link> Git Flow &amp; GitHub Flow &amp; GitLab Flow 三者的比較 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> 觀念補充 </a> <nav class=md-nav aria-label=觀念補充> <ul class=md-nav__list> <li class=md-nav__item> <a href=#terminal class=md-nav__link> 終端機(Terminal)是什麼? </a> </li> <li class=md-nav__item> <a href=#vim-gitvim class=md-nav__link> Vim 是Git的預設編輯器,Vim主要常用的兩種模式 </a> </li> <li class=md-nav__item> <a href=#sha-1 class=md-nav__link> SHA-1(安全散列演算法) 介紹 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> 參考資料來源 </a> <nav class=md-nav aria-label=參考資料來源> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_13 class=md-nav__link> 書籍 </a> </li> <li class=md-nav__item> <a href=#medium class=md-nav__link> Medium </a> </li> <li class=md-nav__item> <a href=#it class=md-nav__link> iT邦幫忙 </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> 練習場 </a> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> 免費線上學習資源 </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex=0> MkDocs Info <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=false> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> MkDocs Info </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../mkdocs_info/mkdocs/ class=md-nav__link> MkDocs </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#git class=md-nav__link> 自主學習 Git 的觀念和指令後做的統整 &amp; 學習筆記 </a> <nav class=md-nav aria-label="自主學習 Git 的觀念和指令後做的統整 & 學習筆記"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 安裝方式 </a> <nav class=md-nav aria-label=安裝方式> <ul class=md-nav__list> <li class=md-nav__item> <a href=#windows class=md-nav__link> Windows系統 </a> </li> <li class=md-nav__item> <a href=#macos class=md-nav__link> MacOS系統 </a> </li> <li class=md-nav__item> <a href=#linux class=md-nav__link> Linux系統 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#git_1 class=md-nav__link> 設定Git </a> </li> <li class=md-nav__item> <a href=#git_2 class=md-nav__link> Git 基礎常用指令 </a> <nav class=md-nav aria-label="Git 基礎常用指令"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git_3 class=md-nav__link> 初始化該目錄,主要目的是讓Git開始對這個目錄進行版本控制 </a> </li> <li class=md-nav__item> <a href=#git_4 class=md-nav__link> 把這個檔案交給Git來控管 </a> </li> <li class=md-nav__item> <a href=#staging-area class=md-nav__link> 把暫存區(staging area)的檔案提交到倉庫存檔 </a> </li> <li class=md-nav__item> <a href=#git_5 class=md-nav__link> 想檢視Git紀錄 </a> </li> <li class=md-nav__item> <a href=#git_6 class=md-nav__link> 刪除Git檔案 </a> </li> <li class=md-nav__item> <a href=#_2 class=md-nav__link> 變更檔名 </a> </li> <li class=md-nav__item> <a href=#commit class=md-nav__link> 修改Commit紀錄 </a> </li> <li class=md-nav__item> <a href=#gitgit-server-gitignore class=md-nav__link> 如果有特定檔案不想放在Git裡面一起備份或是上傳到Git Server的話,例如:資料庫密碼,雲端伺服器的金鑰...可以加入 .gitignore中 </a> </li> <li class=md-nav__item> <a href=#commit_1 class=md-nav__link> 檢視特定檔案的commit紀錄 </a> </li> <li class=md-nav__item> <a href=#_3 class=md-nav__link> 想要知道某個檔案的某一行是誰寫的 </a> </li> <li class=md-nav__item> <a href=#working-directory-rm class=md-nav__link> 在工作目錄(working directory)想要復原不小心透過 rm 指令刪除的檔案 </a> </li> <li class=md-nav__item> <a href=#commit_2 class=md-nav__link> 如果想重新編輯剛才的commit </a> </li> <li class=md-nav__item> <a href=#tagcommmit class=md-nav__link> 新增Tag物件到Commmit物件 </a> </li> <li class=md-nav__item> <a href=#branch class=md-nav__link> 分支(branch)操作 </a> </li> <li class=md-nav__item> <a href=#commit_3 class=md-nav__link> 該如何回復到上一次commit紀錄的狀態? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_4 class=md-nav__link> 觀念介紹 </a> <nav class=md-nav aria-label=觀念介紹> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git_7 class=md-nav__link> Git 其實是一種分散式的版本控制系統 </a> </li> <li class=md-nav__item> <a href=#git_8 class=md-nav__link> Git 的優點 </a> </li> <li class=md-nav__item> <a href=#git-snapshot class=md-nav__link> Git 是用快照(snapshot)在做版本控制的 </a> </li> <li class=md-nav__item> <a href=#git-blobtreecommittag class=md-nav__link> Git 的四大物件(Blob,Tree,Commit,Tag)觀念介紹 </a> </li> <li class=md-nav__item> <a href=#git-count-objects class=md-nav__link> $ git count-objects: 可以檢視目前有多少物件和用掉多少儲存空間 </a> </li> <li class=md-nav__item> <a href=#git_9 class=md-nav__link> 在使用Git時,指令要在正確的目錄下才能正常運作 </a> </li> <li class=md-nav__item> <a href=#gitstaging-areaindex class=md-nav__link> 在Git術語中,暫存區(staging area)=索引(index) </a> </li> <li class=md-nav__item> <a href=#git-working-directorystaging-arearepository class=md-nav__link> Git 世界裡的的三大區域---工作目錄(working directory),暫存區(staging area),儲存庫(repository) </a> </li> <li class=md-nav__item> <a href=#git-add-git-commit class=md-nav__link> 為什麼每次都要先$ git add 再 $ git commit </a> </li> <li class=md-nav__item> <a href=#gitid-sha-1 class=md-nav__link> Git物件的id是怎麼計算出來的? (SHA-1演算法) </a> </li> <li class=md-nav__item> <a href=#head class=md-nav__link> HEAD是什麼? </a> </li> <li class=md-nav__item> <a href=#orig_head class=md-nav__link> ORIG_HEAD是什麼? </a> </li> <li class=md-nav__item> <a href=#branch_1 class=md-nav__link> 分支(branch)是什麼? </a> </li> <li class=md-nav__item> <a href=#detached-head class=md-nav__link> Detached HEAD (斷頭) 是什麼? </a> </li> <li class=md-nav__item> <a href=#tag class=md-nav__link> Tag (標籤) 是什麼? </a> </li> <li class=md-nav__item> <a href=#git-git-gc class=md-nav__link> Git的資源回收機制($ git gc)是怎麼運作的呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_5 class=md-nav__link> 觀念釐清 </a> <nav class=md-nav aria-label=觀念釐清> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git_10 class=md-nav__link> Git無法控管 空目錄/ </a> </li> <li class=md-nav__item> <a href=#git-rm-cached-vs-gitignore class=md-nav__link> $ git rm --cached V.S. .gitignore 比較 </a> </li> <li class=md-nav__item> <a href=#git-git class=md-nav__link> 在專案中的整個.git/ 目錄是Git版控的核心檔案 </a> </li> <li class=md-nav__item> <a href=#git-reset-commit class=md-nav__link> $ git reset 是用來"前往"到指定的Commit物件上的 </a> </li> <li class=md-nav__item> <a href=#gitblobtreecommittag class=md-nav__link> Git四大物件(Blob,Tree,Commit,Tag)彼此之間其實是平行關係 </a> </li> <li class=md-nav__item> <a href=#gitsnapshot class=md-nav__link> Git其實不是在做差異備份,而是在為當時的專案建立快照(snapshot) </a> </li> <li class=md-nav__item> <a href=#catdogdogcat class=md-nav__link> 把cat分支合併到dog分支&amp;把dog分支合併到cat分支有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#_6 class=md-nav__link> 合併分支其實不是真的在合併分支! </a> </li> <li class=md-nav__item> <a href=#resetrebaserevert class=md-nav__link> Reset、Rebase、Revert 三個指令有什麼差別? </a> </li> <li class=md-nav__item> <a href=#tagbranch class=md-nav__link> 標籤(Tag)跟分支(branch)有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#unreachable-dangling class=md-nav__link> Unreachable物件 &amp; Dangling物件 有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#git-log-git-reflog class=md-nav__link> $ git log &amp; git reflog 有什麼不同呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_7 class=md-nav__link> 實戰情境題 </a> <nav class=md-nav aria-label=實戰情境題> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git-add class=md-nav__link> 如果在git add之後又修改了那個檔案的內容呢? </a> </li> <li class=md-nav__item> <a href=#git-reset-hard class=md-nav__link> 如果不小心使用$ git reset --hard 模式,能救回來嗎? </a> </li> <li class=md-nav__item> <a href=#commit_4 class=md-nav__link> 如果這次只想commit一個檔案中的部份內容的話,該怎麼做呢? </a> </li> <li class=md-nav__item> <a href=#branch_2 class=md-nav__link> 如果修改專案的某些檔案到一半,卻不小心先切換到別的分支(branch),該怎麼辦? </a> </li> <li class=md-nav__item> <a href=#_8 class=md-nav__link> 如果不小心把還沒合併的分支刪掉了,該怎麼挽救? </a> </li> <li class=md-nav__item> <a href=#commitbranch class=md-nav__link> 如果想從過去的某次commit紀錄再長一個新的分支(branch)出來,該如何做呢? </a> </li> <li class=md-nav__item> <a href=#both-modified class=md-nav__link> 當兩個分支都編輯了同一個檔案(both modified 狀態),造成合併分支時發生衝突了,該怎麼解決呢? </a> </li> <li class=md-nav__item> <a href=#_9 class=md-nav__link> 目前的工作做到一半,如果要臨時切換到別的任務,該怎麼做呢? </a> </li> <li class=md-nav__item> <a href=#exgit class=md-nav__link> 如果不小心將機敏資料(ex:帳號、密碼)放在Git裡,想把它刪掉,該怎麼做呢? </a> </li> <li class=md-nav__item> <a href=#commit_5 class=md-nav__link> 可以只取用某個分支的其中某幾個commit嗎? </a> </li> <li class=md-nav__item> <a href=#git_11 class=md-nav__link> 如何把一個檔案從Git版控中真正的移除掉呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#-github class=md-nav__link> 遠端共同協作篇---以 GitHub 為例 </a> <nav class=md-nav aria-label="遠端共同協作篇---以 GitHub 為例"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#github class=md-nav__link> GitHub 基礎使用操作說明 </a> </li> <li class=md-nav__item> <a href=#github-repositoryrepositorygithub class=md-nav__link> 新建一個GitHub repository,並推送本地端repository到GitHub上 </a> </li> <li class=md-nav__item> <a href=#repositorypull class=md-nav__link> 從遠端repository利用Pull下載並更新 </a> </li> <li class=md-nav__item> <a href=#pushrepository class=md-nav__link> 為什麼有時候會推送(Push)不上去遠端repository呢? </a> </li> <li class=md-nav__item> <a href=#repository class=md-nav__link> 從伺服器上複製遠端repository下來 </a> </li> <li class=md-nav__item> <a href=#clone-pull class=md-nav__link> Clone(複製) 和 Pull(拉下來更新) 有什麼不同呢? </a> </li> <li class=md-nav__item> <a href=#pull-request class=md-nav__link> 利用Pull Request來跟其它開發者的開源專案做互動 </a> </li> <li class=md-nav__item> <a href=#fork class=md-nav__link> 如何跟上當初Fork的專案的進度呢? </a> </li> <li class=md-nav__item> <a href=#_10 class=md-nav__link> 如何刪除遠端分支呢? </a> </li> <li class=md-nav__item> <a href=#git-push-f-pushrepository class=md-nav__link> 什麼時機適合用$ git push -f 來強制推送(Push)上去到遠端repository呢? </a> </li> <li class=md-nav__item> <a href=#patchrepository class=md-nav__link> 如何透過更新檔(Patch)來更新本機端的repository的內容呢? </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#git_12 class=md-nav__link> Git 常見的團隊工作流程 &amp; 規範 </a> <nav class=md-nav aria-label="Git 常見的團隊工作流程 & 規範"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#git-flow class=md-nav__link> Git Flow介紹 </a> </li> <li class=md-nav__item> <a href=#github-flow class=md-nav__link> GitHub Flow介紹 </a> </li> <li class=md-nav__item> <a href=#gitlab-flow class=md-nav__link> GitLab Flow介紹 </a> </li> <li class=md-nav__item> <a href=#git-flow-github-flow-gitlab-flow class=md-nav__link> Git Flow &amp; GitHub Flow &amp; GitLab Flow 三者的比較 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_11 class=md-nav__link> 觀念補充 </a> <nav class=md-nav aria-label=觀念補充> <ul class=md-nav__list> <li class=md-nav__item> <a href=#terminal class=md-nav__link> 終端機(Terminal)是什麼? </a> </li> <li class=md-nav__item> <a href=#vim-gitvim class=md-nav__link> Vim 是Git的預設編輯器,Vim主要常用的兩種模式 </a> </li> <li class=md-nav__item> <a href=#sha-1 class=md-nav__link> SHA-1(安全散列演算法) 介紹 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_12 class=md-nav__link> 參考資料來源 </a> <nav class=md-nav aria-label=參考資料來源> <ul class=md-nav__list> <li class=md-nav__item> <a href=#_13 class=md-nav__link> 書籍 </a> </li> <li class=md-nav__item> <a href=#medium class=md-nav__link> Medium </a> </li> <li class=md-nav__item> <a href=#it class=md-nav__link> iT邦幫忙 </a> </li> <li class=md-nav__item> <a href=#_14 class=md-nav__link> 練習場 </a> </li> <li class=md-nav__item> <a href=#_15 class=md-nav__link> 免費線上學習資源 </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <a href=https://github.com/Hans-Tsai/hans_blog/edit/master/docs/version_control/git.md title="Edit this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"/></svg> </a> <a href=https://github.com/Hans-Tsai/hans_blog/raw/master/docs/version_control/git.md title="View source of this page" class="md-content__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.15 8.15 0 0 1-1.23-2Z"/></svg> </a> <h1 id=git-learn>Git Learn<a class=headerlink href=#git-learn title="Permanent link">&para;</a></h1> <h2 id=git>自主學習 Git 的觀念和指令後做的統整 &amp; 學習筆記<a class=headerlink href=#git title="Permanent link">&para;</a></h2> <hr> <h3 id=_1>安裝方式<a class=headerlink href=#_1 title="Permanent link">&para;</a></h3> <h4 id=windows>Windows系統<a class=headerlink href=#windows title="Permanent link">&para;</a></h4> <ul> <li>連結: <a href=https://git-scm.com/download/win>https://git-scm.com/download/win</a></li> <li>安裝完後,使用Git Bash就可以操作Git了</li> <li>$ <code>which git</code> // /mingw/bin/git</li> <li>$ <code>git --version</code> // git version 2.28.0.windows.1</li> <li>GUI client推薦: SourceTree, GitHub Desktop<ul> <li>下載連結: <a href=https://git-scm.com/downloads/guis>https://git-scm.com/downloads/guis</a></li> </ul> </li> <li>補充: Git Bash不同於Windows內建的"命令提示字元",它本身模擬了Linux的 Bash</li> </ul> <h4 id=macos>MacOS系統<a class=headerlink href=#macos title="Permanent link">&para;</a></h4> <ul> <li>連結: <a href=https://git-scm.com/download/mac>https://git-scm.com/download/mac</a></li> <li>或是利用Homebrew安裝</li> <li>$ <code>brew install git</code></li> <li>補充: Homebrew是一個MacOS專屬的套件管理包工具,有點像是Linux的apt-get之類的安裝工具,通常只要一行指令就可以完成下載.編譯.安裝</li> <li>GUI client推薦: SourceTree, GitHub Desktop<ul> <li>下載連結: <a href=https://git-scm.com/downloads/guis>https://git-scm.com/downloads/guis</a></li> </ul> </li> </ul> <h4 id=linux>Linux系統<a class=headerlink href=#linux title="Permanent link">&para;</a></h4> <ul> <li>連結: <a href=https://git-scm.com/download/linux>https://git-scm.com/download/linux</a></li> <li>利用apt-get安裝</li> <li>$ <code>sudo apt-get install git</code> // 在Linux系統中要安裝軟體要先切換成root權限</li> <li>GUI client推薦: gitk<ul> <li>$ <code>sudo apt-get install gitk</code></li> </ul> </li> </ul> <hr> <h3 id=git_1>設定Git<a class=headerlink href=#git_1 title="Permanent link">&para;</a></h3> <blockquote> <p><code>git config</code> - Get and set repository or global options<br> <code>git log</code> - Show commit logs</p> </blockquote> <ul> <li>所有Git相關的設定都會儲存在 <code>~/.gitconfig</code> 這個檔案裡</li> <li>設定使用者的Email＆username</li> <li>$ <code>git config --global user.name "Hans-Tsai"</code></li> <li>$ <code>git config --global user.email "lgs840522@gmail.com"</code></li> <li>檢視目前的設定</li> <li>$ <code>cat ~/.gitconfig</code></li> <li>$ <code>git config --list</code></li> <li>設定Git要使用的編輯器(預設是使用Vim)</li> <li>$ <code>git config --global core.editor emacs</code></li> <li>設定Git客製化縮寫指令</li> <li>$ <code>git config --global alias.co checkout</code> </li> <li>$ <code>git config --global alias.br branch</code></li> <li>$ <code>git config --global alias.st status</code></li> <li>$ <code>git config --global alias.ls 'log --graph --pretty=format:"%h &lt;%an&gt; %ar %s"'</code></li> </ul> <hr> <h3 id=git_2>Git 基礎常用指令<a class=headerlink href=#git_2 title="Permanent link">&para;</a></h3> <blockquote> <p><code>git init</code> - Create an empty Git repository or reinitialize an existing one<br> <code>git status</code> - Show the working tree status<br> <code>git add</code> - Add file contents to the index<br> <code>git commit</code> - Record changes to the repository<br> <code>git log</code> - Show commit logs<br> <code>git rm</code> - Remove files from the working tree and from the index<br> <code>git mv</code> - Move or rename a file, a directory, or a symlink<br> <code>gitignore</code> - Specifies intentionally untracked files to ignore<br> <code>git clean</code> - Remove untracked files from the working tree<br> <code>git blame</code> - Show what revision and author last modified each line of a file<br> <code>git checkout</code> - Switch branches or restore working tree files<br> <code>git switch</code> - Switch branches<br> <code>git restore</code> - Restore working tree files<br> <code>git reset</code> - Reset current HEAD to the specified state<br> <code>git reflog</code> - Manage reflog information<br> <code>git tag</code> - Create, list, delete or verify a tag object signed with GPG<br> <code>git merge</code> - Join two or more development histories together<br> <code>git rebase</code> - Reapply commits on top of another base tip<br> <code>git revert</code> - Revert some existing commits<br></p> </blockquote> <h4 id=git_3>初始化該目錄,主要目的是讓Git開始對這個目錄進行版本控制<a class=headerlink href=#git_3 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git init</code></li> <li>會在該目錄裡面建立一個 <code>.git/</code> 隱藏檔目錄,整個Git的精華都會在這個目錄裡面</li> <li>如果該目錄不想再被Git做版本控制,只要將<code>.git/</code>目錄整個刪除就可以 </li> <li>$ <code>rm -rf .git/</code> </li> <li>注意:整個專案目錄裡,什麼檔案或目錄刪了都救得回來,但 <code>.git/</code> 目錄只要刪了就沒辦法了 !</li> <li>查詢現在這個目錄的"狀態"</li> <li>$ <code>git status</code></li> <li>Untracked files =&gt; 代表這個檔案尚未被加到Git版控系統裡,還沒開始正式被"追蹤",它只是剛剛才加入到這個目錄裡而已</li> <li><img alt=Untracked_files圖解說明 src=../../assets/pics/git/Untracked_files%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> <h4 id=git_4>把這個檔案交給Git來控管<a class=headerlink href=#git_4 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git add welcome.html</code></li> <li>剛才的檔案 <code>welcome.html</code>從Untracked變成new file狀態 =&gt; 表示這個檔案已經被安置到暫存區(Staging Area),等待稍後跟其他檔案一起被存到儲存庫裡面</li> <li><img alt=git_add將檔案加入版控中圖解說明 src=../../assets/pics/git/git%20add%E5%B0%87%E6%AA%94%E6%A1%88%E5%8A%A0%E5%85%A5%E7%89%88%E6%8E%A7%E4%B8%AD%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>如果想將全部檔案一口氣加入暫存區,可以使用--all參數;不論檔案狀態是Untracked files或是Changes not staged for commit,都會一口氣變成Changes to committed<ul> <li>$ <code>git add --all</code> or $ <code>git add -A</code> </li> <li>$ <code>git add --all</code> =&gt;會將整個專案裡的全部異動檔案加到暫存區,不受限這個指令在哪一層目錄執行</li> <li>$ <code>git add .</code>=&gt;只會把當前執行command的那個目錄以及它的子目錄的異動檔案加到暫存區,所以在哪一層目錄執行這個command很重要</li> </ul> </li> <li>如果想要取消剛剛加入到暫存區(Staging Area)的檔案的話,並將該檔案丟回到工作目錄(Working Directory)中,可以利用以下指令<ul> <li>$ <code>git restore --staged &lt;要從暫存區退回到工作目錄的檔案&gt;</code>: 這樣就可以把剛剛加入到暫存區(Staging Area)的檔案丟回到工作目錄(Working Directory)中</li> <li><code>-S</code> (=&gt; <code>--staged</code>): 指定要從哪個位置(location)<code>回復</code>(Restore)到工作目錄(Working Directory)中</li> <li><img alt="利用git restore --staged 來將剛剛加入到暫存區的檔案丟回到工作目錄中,讓該檔案不要繼續被Git追蹤到_圖解說明" src=../../assets/pics/git/%E5%88%A9%E7%94%A8git%20restore%20--staged%20%E4%BE%86%E5%B0%87%E5%89%9B%E5%89%9B%E5%8A%A0%E5%85%A5%E5%88%B0%E6%9A%AB%E5%AD%98%E5%8D%80%E7%9A%84%E6%AA%94%E6%A1%88%E4%B8%9F%E5%9B%9E%E5%88%B0%E5%B7%A5%E4%BD%9C%E7%9B%AE%E9%8C%84%E4%B8%AD%2C%E8%AE%93%E8%A9%B2%E6%AA%94%E6%A1%88%E4%B8%8D%E8%A6%81%E7%B9%BC%E7%BA%8C%E8%A2%ABGit%E8%BF%BD%E8%B9%A4%E5%88%B0_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> </li> </ul> <h4 id=staging-area>把暫存區(staging area)的檔案提交到倉庫存檔<a class=headerlink href=#staging-area title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git commit -m "git commit練習"</code></li> <li>-m = (--messge)參數:代表在這次commit做了什麼事情的說明字串,中英文皆可,言簡意賅就好; $ <code>git commit</code>預設-m參數是必填的</li> <li><img alt="git commit練習圖解說明" src=../../assets/pics/git/git%20commit%E7%B7%B4%E7%BF%92%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>可以不用二段式commit,也可以用$ <code>git commit -a -m "update content"</code> 來達到$ <code>git add</code> <ul> <li>$ <code>git commit -m</code></li> </ul> </li> <li>Git每次commit都只會處理暫存區(staging area)裡的內容,也就是說,如果在執行 $ <code>git commit</code> 之前還沒被加到暫存區裡的檔案,就不會被commit到儲存庫了</li> <li>提醒:要完成commit才算是完成整個流程喔!</li> </ul> <h4 id=git_5>想檢視Git紀錄<a class=headerlink href=#git_5 title="Permanent link">&para;</a></h4> <ul> <li>使用$ <code>git log</code>指令,越新的資訊會在越上面,並會得到以下三個資訊</li> <li>Commit作者是誰? =&gt; 人是誰殺的?</li> <li>什麼時候commit的? =&gt; 什麼時候殺的?</li> <li>每次的commit大概做了哪些事? =&gt; 怎麼殺的?</li> <li><img alt="git log圖解說明越新的資訊會在越上面" src=../../assets/pics/git/git%20log%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E%E8%B6%8A%E6%96%B0%E7%9A%84%E8%B3%87%E8%A8%8A%E6%9C%83%E5%9C%A8%E8%B6%8A%E4%B8%8A%E9%9D%A2.png></li> <li>也可以使用參數將$ <code>git log</code>輸出成不同的形式<ul> <li>$ <code>git log --oneline --graph</code> </li> <li><code>--oneline</code>:每個commit物件僅顯示成一行</li> <li><code>--graph</code>:用圖表來表示commit物件之間的線性關係</li> <li><img alt="git log --oneline --graph圖解說明" src=../../assets/pics/git/git%20log%20--oneline%20--graph%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> </li> <li>可以透過$ <code>git log</code>尋找特定author的commit物件<ul> <li>$ <code>git log --oneline --author="Hans"</code></li> <li>作者(author)是最初修改的人</li> <li>提交者(committer)是最後套用該工作成果的人</li> </ul> </li> <li>可以透過$ <code>git log</code>尋找符合特定字串的commit"訊息(-m)"<ul> <li>$ <code>git log --oneline --grep="initial"</code></li> </ul> </li> <li>可以透過$ <code>git log</code>搜尋在所有commit物件中,有哪些符合特定條件的<ul> <li>$ <code>git log -S "Ruby"</code></li> </ul> </li> <li>可以透過$ <code>git log</code>搭配參數來查詢特定時間內的commit物件<ul> <li>$ <code>git log --oneline --since "9am" --until "12am" --after="2017-01"</code></li> <li><code>--since</code>:"hham/pm"</li> <li><code>--until</code>:"hham/pm"</li> <li><code>--after</code>:"yyyy-mm"</li> </ul> </li> </ul> <h4 id=git_6>刪除Git檔案<a class=headerlink href=#git_6 title="Permanent link">&para;</a></h4> <ul> <li>刪除檔案對Git來說都是一種"修改" </li> <li>可以透過系統指令刪除檔案$ <code>rm welcome.html</code><ul> <li>這時候的檔案會是deleted狀態</li> <li><img alt=rm刪除檔案顯示為deleted狀態 src=../../assets/pics/git/rm%E5%88%AA%E9%99%A4%E6%AA%94%E6%A1%88%E9%A1%AF%E7%A4%BA%E7%82%BAdeleted%E7%8B%80%E6%85%8B.png></li> <li>還需要再執行$ <code>git add xxx.txt</code> 才會將這個"刪除"加到暫存區</li> </ul> </li> <li>可以透過$ <code>git rm welcome.html</code><ul> <li>$ <code>git rm</code> = <code>rm xxx.txt</code> + <code>git add xxx.txt</code></li> <li>$ <code>git rm</code> 相當於先$ <code>rm</code>刪除檔案後再$ <code>git add</code> 加入暫存區的兩段式動作</li> <li><img alt="git rm=rm+git add 圖解說明" src=../../assets/pics/git/git%20rm%3Drm%2Bgit%20add%20%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>不管是系統指令的$ <code>rm</code>或是$ <code>git rm</code>都真的會把檔案從工作目錄刪掉,但如果只是不想讓檔案再被Git控管,可以加上<code>--cached</code>參數</li> <li>$ <code>git rm xxx.html --cached</code></li> <li><code>--cached</code>:不會真的將檔案刪除掉,僅將檔案脫離Git控管,成為Untracked file</li> </ul> </li> </ul> <h4 id=_2>變更檔名<a class=headerlink href=#_2 title="Permanent link">&para;</a></h4> <ul> <li>跟"刪除"檔案一樣,變更檔名也是一種"修改"</li> <li><img alt=mv檔名也算是一種修改圖解說明 src=../../assets/pics/git/mv%E6%AA%94%E5%90%8D%E4%B9%9F%E7%AE%97%E6%98%AF%E4%B8%80%E7%A8%AE%E4%BF%AE%E6%94%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>雖然只是透過系統指令$ <code>rm</code> 來改名,但對Git來說會被認為是兩個動作,後續仍須使用$ <code>git add world.html</code>指令來把這些異動加入暫存區<ul> <li>刪除<sub>~hello.html</sub>~檔案</li> <li>新增world.html檔案(變成Untracked file)</li> </ul> </li> <li>可以透過$ <code>git mv world.html hans_world.html</code><ul> <li>$ <code>git mv</code> = <code>mv 新檔名.html</code> + <code>git add 新檔名.html</code></li> <li>$ <code>git mv</code> 相當於先$ <code>mv</code>修改檔名後再$ <code>git add</code> 加入暫存區的兩段式動作</li> <li><img alt="git mv=mv+git add圖解說明" src=../../assets/pics/git/git%20mv%3Dmv%2Bgit%20add%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>這樣<code>hans_world.html</code>就會直接變成<code>renamed file</code></li> </ul> </li> <li>其實Git是根據檔案的"內容"去算出SHA-1的值,所以Git不是很在乎你的檔案叫什麼名稱,只在乎檔案的內容是什麼。所以當進行更改檔名的時候,Git並沒有為此做出一個新的Blob物件,而僅是指向原來舊的那顆Blob物件;但因為檔案名稱改變了,所以會做出一顆新的Tree物件喔!</li> </ul> <h4 id=commit>修改Commit紀錄<a class=headerlink href=#commit title="Permanent link">&para;</a></h4> <ul> <li>想修改commit紀錄有以下4種方法<ul> <li>把<code>.git/</code>目錄整個刪除 -&gt; 不建議,等於砍掉重練</li> <li>使用$ <code>git rebase</code> 來修改歷史</li> <li>先把commit用$ <code>git reset</code>拆掉,整理後再重新commit</li> <li>使用<code>git commit --amend</code>參數來修改最後一次的commit物件 -&gt; 較推薦此作法!</li> </ul> </li> <li>可以透過$ <code>git commit --amend -m "新的commit message"</code>來修改commit紀錄<ul> <li><code>--amend</code>:只能修改"最近一次"的commit紀錄</li> <li><img alt="git commit --amend -m修改最近一次commit message練習圖解說明" src=../../assets/pics/git/git%20commit%20--amend%20-m%E4%BF%AE%E6%94%B9%E6%9C%80%E8%BF%91%E4%B8%80%E6%AC%A1commit%20message%E7%B7%B4%E7%BF%92%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> </li> <li>如果在完成commit後,卻發現有一個檔案忘了加到這次的commit中,但不想因為這個檔案再重新發送一次commit,想把這個檔案加入最近一次commit,此時有兩個做法<ul> <li>使用$ <code>git reset</code> 把最後一次的commit拆掉,加入新檔案後再重新commit</li> <li>使用<code>--amend</code>參數進行commit</li> <li>$ 先 <code>git add pizza.html</code>,將Untracked file 加入追蹤</li> <li>$ 再 <code>git commit --amend --no-edit</code>,把這個檔案併入最後一次的commit中,而後面的<code>--no-edit</code>參數就是不要開啟vim編輯視窗來編輯commit message的意思</li> <li><img alt="git commit --amend --no-edit參數圖解說明" src=../../assets/pics/git/git%20commit%20--amend%20--no-edit%E5%8F%83%E6%95%B8%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> </li> <li>提醒:即便"只是修改commit message",仍然會產生新的commit id,因為這樣對Git來說commit物件的內容是有"變動"的,所以Git會重新計算並產生一顆新的Commit物件,也就是說這其實算是一次全新的commit</li> <li>如果想修改更早的commit紀錄,就必須使用$ <code>git rebase</code> 指令了<ul> <li>可參考<a href=#分支branch操作>分支(branch)操作</a>的 $ <code>git rebase -i</code> 章節 </li> </ul> </li> <li>團隊開發守則:即便只是修改commit message,不管如何它就是修改了一次歷史,所以請盡量"不要"在已經<code>push</code>出去之後再修改,否則可能會造成其他人的困擾</li> </ul> <h4 id=gitgit-server-gitignore>如果有特定檔案不想放在Git裡面一起備份或是上傳到Git Server的話,例如:資料庫密碼,雲端伺服器的金鑰...可以加入 <code>.gitignore</code>中<a class=headerlink href=#gitgit-server-gitignore title="Permanent link">&para;</a></h4> <ul> <li>可以在專案中建立一個 <code>.gitignore</code> 的檔案,裡面可以設定想要忽略的規則</li> <li><code>.gitignore</code>只要一被建立並符合規則就會生效,即使這個檔案還沒被commit或是還沒被push到Git Server,這要一來整個專案的人都可以共享這個"忽略規則"的設定</li> <li>想查詢在使⽤的⼯具或程式語⾔通常會忽略哪些檔案,可以到GitHub上有整理了⼀份各種程式語⾔常⾒的 <code>.gitignore</code> 檔案<ul> <li>github/gitignore repository連結:<a href=https://github.com/github/gitignore>https://github.com/github/gitignore</a></li> </ul> </li> <li>可以利用<code>-f</code>參數,來無視 <code>.gitignore</code>的忽略,強制將檔案加入Git追蹤範圍中<ul> <li>$ <code>git add -f xxx.tmp</code></li> <li><img alt="git add -f參數來無視gitignore的設定" src=../../assets/pics/git/git%20add%20-f%E5%8F%83%E6%95%B8%E4%BE%86%E7%84%A1%E8%A6%96gitignore%E7%9A%84%E8%A8%AD%E5%AE%9A.png></li> <li>提醒: <code>.gitignore</code> 檔案設定的規則,只對"在規則設定之後"的檔案有效</li> </ul> </li> <li>想一次將被 <code>.gitignore</code> 忽略的檔案們一次刪除,可以使用$ <code>git clean</code>來完成<ul> <li>$ <code>git clean</code> 可以將工作目錄(working directory)中的所有Untracked files都一次刪除</li> <li>$ <code>git clean -fX</code></li> <li>-f: 強制執行</li> <li>-X: 只移除被Git忽略的檔案(有在.gitignore中提到的)</li> </ul> </li> </ul> <h4 id=commit_1>檢視特定檔案的commit紀錄<a class=headerlink href=#commit_1 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git log -p xxx.html</code><ul> <li>-p: 可以更詳細的檢視每一次的commit到底做了哪些修改</li> <li>補充: 前面的"+"是新增,"-"是刪除</li> <li><img alt="git log -p 檢視特定檔案詳細的每一筆commit紀錄" src=../../assets/pics/git/git%20log%20-p%20%E6%AA%A2%E8%A6%96%E7%89%B9%E5%AE%9A%E6%AA%94%E6%A1%88%E8%A9%B3%E7%B4%B0%E7%9A%84%E6%AF%8F%E4%B8%80%E7%AD%86commit%E7%B4%80%E9%8C%84.gif></li> </ul> </li> </ul> <h4 id=_3>想要知道某個檔案的某一行是誰寫的<a class=headerlink href=#_3 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git blame xxx.html</code></li> <li>可以詳細地看出來每一行是誰在什麼時候寫的</li> <li>每一行前面的SHA-1值就是每一個Commit物件的識別代碼</li> <li><img alt="git blame圖解說明" src=../../assets/pics/git/git%20blame%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.gif></li> <li>$ <code>git blame -L xxx.html</code><ul> <li>-L <start>,<end>: 可以只顯示指定行數的內容</li> </ul> </li> </ul> <h4 id=working-directory-rm>在工作目錄(working directory)想要復原不小心透過 <code>rm</code> 指令刪除的檔案<a class=headerlink href=#working-directory-rm title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git checkout</code>可以用來 (在Git <code>Version 2.23.0</code> 之後)<ul> <li>切換分支(= $ <code>git switch</code>)</li> <li>恢復工作目錄(working directory)裡的文件(= $ <code>git restore</code>)</li> <li>當$ <code>git checkout "分支名稱"</code> 時,就會切換到指定的分支</li> <li>例如:$ <code>git checkout -b tiger</code>: 切換到<code>tiger</code>分支,如果沒有該分支的話,就新增一個<code>tiger</code>分支<ul> <li><code>-b &lt;新的分支名稱&gt;</code>: (=&gt; <code>branch</code>): 切換到<code>&lt;新的分支名稱&gt;</code>,如果沒有的話,就新增一個<code>&lt;該分支&gt;</code></li> </ul> </li> <li>當$ <code>git checkout "檔案名稱 or 路徑"</code> 時,Git就會到 <code>.git/</code> 目錄裡拉一份到目前的工作目錄(working directory)</li> </ul> </li> <li>$ <code>git checkout xxx.html</code> 可以將工作目錄(working directory)中不小心刪除(<code>rm</code>)掉的指定檔案復原回來</li> <li>例如: <code>pizza.html</code> 從deleted status變回原本的狀態</li> <li>也可以利用 $ <code>git checkout .</code> 一口氣把所有工作目錄(working directory)中被刪掉的檔案救回來</li> <li><img alt="git checkout復原工作目錄不小心rm的檔案圖解說明" src=../../assets/pics/git/git%20checkout%E5%BE%A9%E5%8E%9F%E5%B7%A5%E4%BD%9C%E7%9B%AE%E9%8C%84%E4%B8%8D%E5%B0%8F%E5%BF%83rm%E7%9A%84%E6%AA%94%E6%A1%88%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>$ <code>git checkout HEAD~2 yyy.html</code><ul> <li>這樣就會到 <code>.git/</code> 裡拿距離現在兩個版本以前的 yyy.html 來覆蓋現在工作目錄(working directory)的 yyy.html ,但要注意的是,這同時也會更新暫存區(staging area)的狀態喔 </li> </ul> </li> <li>以此類推, $ <code>git checkout HEAD~2</code><ul> <li>這樣就會拿距離現在兩個版本以前的檔案來覆蓋現在工作目錄(working directory)裡的檔案,同時也更新暫存區(staging area)裡的狀態</li> </ul> </li> </ul> <h4 id=commit_2>如果想重新編輯剛才的commit<a class=headerlink href=#commit_2 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git log --oneline</code> 顯示的歷史commit紀錄是由新到舊(上到下)<ul> <li><img alt="git log由新到舊的歷史commit紀錄" src=../../assets/pics/git/git%20log%E7%94%B1%E6%96%B0%E5%88%B0%E8%88%8A%E7%9A%84%E6%AD%B7%E5%8F%B2commit%E7%B4%80%E9%8C%84.png></li> </ul> </li> <li>利用 $ <code>git reset f06546a</code> 來回溯到過去指定的Commit物件中<ul> <li>可以使用"相對"或是"絕對"的表示方式</li> <li><code>^</code> : 前一次</li> <li><code>~次數</code> : 要倒退至幾次commit以前</li> <li><code>SHA-1值</code>: 絕對的表示方式</li> <li>所以$ <code>git reset f06546a^^</code> = $ <code>git reset f06546a~2</code></li> <li>例如: $ <code>git reset f06546a^</code> =&gt;代表回到該commit的前一次commit紀錄中</li> <li>例如: $ <code>git reset master^</code> =&gt;代表回到master分支的前一次commit紀錄中</li> <li>例如: $ <code>git reset HEAD^</code> =&gt;代表回到HEAD目前指向的分支(該分支指向的commit)的前一次commit紀錄中</li> </ul> </li> <li>$ <code>git reset &lt;模式&gt;</code> ,有三種模式可以選擇,預設為 <code>mixed</code>模式<ul> <li><code>mixed</code> 模式: 這模式下的<code>reset</code>會把暫存區(staging area)的檔案丟掉,但不會動到工作目錄(working directory)的檔案,也就是說commit拆出來的檔案會留在工作目錄,但不會留在暫存區</li> <li><code>soft</code> 模式: 這模式下的<code>reset</code>,工作目錄(working directory)和暫存區(staging area)的檔案都不會被丟掉,因此看起來就只有<code>HEAD</code>在移動而已; 所以commit拆出來的檔案都會直接被存放在暫存區</li> <li><code>hard</code> 模式: 這模式下的<code>reset</code>,不管是暫存區(staging area)和工作目錄(working directory)都會被丟掉</li> <li>小統整: <img alt="git reset <三種模式>統整圖解說明" src=../../assets/pics/git/git%20reset%20%3C%E4%B8%89%E7%A8%AE%E6%A8%A1%E5%BC%8F%3E%E7%B5%B1%E6%95%B4%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/ >https://gitbook.tw/</a></li> <li><code>mixed</code> 模式=&gt; <code>index移除staged標記</code>,變成Modified或是Untracked file,內容是新版的</li> <li><code>soft</code> 模式=&gt; <code>僅移除commit變成新版"未"commit</code>,內容仍是新版的</li> <li><code>hard</code> 模式=&gt; 回到上一版本,<code>這期間的所有變更完全移除</code>,內容及狀態皆是上一版</li> </ul> </li> </ul> <h4 id=tagcommmit>新增<code>Tag物件</code>到<code>Commmit物件</code><a class=headerlink href=#tagcommmit title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git tag -a wow -m "Tag物件-annotated tag 練習"</code><ul> <li>$ <code>git cat-file -t &lt;</code>Tag物件<code>的SHA-1值&gt;</code></li> <li><img alt=Tag物件介紹 src=../../assets/pics/git/Tag%E7%89%A9%E4%BB%B6%E4%BB%8B%E7%B4%B9.png></li> </ul> </li> <li>統整: <code>Tag物件</code>中的有附註Tag(Annotated Tag)會指向某個<code>Commit物件</code></li> </ul> <h4 id=branch>分支(branch)操作<a class=headerlink href=#branch title="Permanent link">&para;</a></h4> <ul> <li><a href=#分支branch是什麼>分支基礎操作可參考</a></li> <li> <p>合併分支的兩種方式($ <code>git merge</code> &amp; $ <code>git rebase</code>)</p> <ul> <li>方法一 : $ <code>git merge</code></li> <li>$ <code>git merge &lt;要合併到的分支名稱&gt;</code>: 可以用來將目前所在的分支(branch)合併到 <code>&lt;要合併到的分支名稱&gt;</code></li> <li>若要合併掉別人的分支是從要被合併掉的分支的開出來的,若要被合併掉的分支沒有修改的話,Git會預設使用快轉模式(fast-forward)來做合併 <ul> <li>$ <code>git merge --ff &lt;要合併到的分支名稱&gt;</code></li> <li><code>--ff</code> (=&gt; 此為Git預設<code>fast-forward</code>模式)</li> <li><img alt="git merge --ff 快轉模式來合併分支的圖解說明" src=../../assets/pics/git/git%20merge%20--ff%20%E5%BF%AB%E8%BD%89%E6%A8%A1%E5%BC%8F%E4%BE%86%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://backlog.com/git-tutorial/tw/stepup/stepup1_4.html>https://backlog.com/git-tutorial/tw/stepup/stepup1_4.html</a></li> </ul> </li> <li>但若原本的那個分支有修改過的話,這時候Git就不會使用快轉模式(<code>fast-forward</code>),此時Git會額外再做出一個新的<code>Commit物件</code>來合併這兩個分支<ul> <li>$ <code>git merge --no-ff &lt;要合併到的分支名稱&gt;</code></li> <li><code>--no-ff</code> (=&gt; 強制"不要"使用fast-forward模式)</li> <li><img alt="git merge --no-ff 強制不要使用快轉模式來合併分支的圖解說明" src=../../assets/pics/git/git%20merge%20--no-ff%20%E5%BC%B7%E5%88%B6%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BF%AB%E8%BD%89%E6%A8%A1%E5%BC%8F%E4%BE%86%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://backlog.com/git-tutorial/tw/stepup/stepup1_4.html>https://backlog.com/git-tutorial/tw/stepup/stepup1_4.html</a></li> </ul> </li> <li>$ <code>git merge --ff-only &lt;要合併到的分支名稱&gt;</code><ul> <li><code>--ff-only</code> (=&gt; 盡可能的優先使用fast-forward模式合併,此時如果無法做到使用fast-forward模式合併的話,Git就會拒絕這次的指令並回傳一個"失敗"的錯誤狀態) </li> </ul> </li> <li><code>情境說明</code>(要用<code>master分支</code>來合併<code>pig分支</code>)</li> <li>先新增一個分支(branch): <code>pig</code></li> <li>建立一個新的檔案,並commit: <code>pig.html</code></li> <li>新增一行文字後,再commit一次: <code>hello, pig</code></li> <li>$ <code>git log</code>: 檢視一下目前的commit歷史紀錄(確認目前是在<code>pig分支</code>並且有<code>兩次commit的紀錄</code>)</li> <li><img alt="git merge分支練習統整的圖解說明" src=../../assets/pics/git/git%20merge%E5%88%86%E6%94%AF%E7%B7%B4%E7%BF%92%E7%B5%B1%E6%95%B4%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.gif></li> <li>要先切回<code>master分支</code></li> <li>$ <code>git checkout master</code></li> <li>$ <code>git merge pig</code>: 將<code>pig分支</code>合併回到<code>master分支</code></li> <li>本來落後<code>pig分支</code>兩次commit紀錄的<code>master分支</code>,現在也已經跟上<code>pig分支</code>的進度了 </li> <li> <p><img alt=將pig分支合併回到master分支 src=../../assets/pics/git/%E5%B0%87pig%E5%88%86%E6%94%AF%E5%90%88%E4%BD%B5%E5%9B%9E%E5%88%B0master%E5%88%86%E6%94%AF.png></p> </li> <li> <p>方法二 : $ <code>git rebase</code></p> </li> <li>$ <code>git rebase &lt;要被rebase的分支名稱&gt;</code></li> <li>可以重新定義<code>分支(branch)</code>參考的基準</li> <li>可以用來將目前所在的分支(branch)合併到 <code>&lt;要被rebase的分支名稱&gt;</code></li> <li><img alt="git rebase參考動圖1" src=../../assets/pics/git/git%20rebase%E5%8F%83%E8%80%83%E5%8B%95%E5%9C%961.gif><br> 參考圖片出處: <a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR22RpLWxsCk1qKLdJynK4BCMyD5FSTvRHta8GvAyJO2ALi4WObsdQ-UWNU">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR22RpLWxsCk1qKLdJynK4BCMyD5FSTvRHta8GvAyJO2ALi4WObsdQ-UWNU</a></li> <li><code>情境說明</code></li> <li>從<code>master</code>分支拆分出兩個分支(<code>elephant</code>,<code>zebra</code>),並分別各commit兩次</li> <li><img alt="git rebase練習畫面_從master分支新增elephant和zebra兩個分支也分別各commit兩次" src=../../assets/pics/git/git%20rebase%20%E7%B7%B4%E7%BF%92%E7%95%AB%E9%9D%A2_%E5%B0%87elephant%E5%88%86%E6%94%AFrebase%E5%88%B0zebra%E5%88%86%E6%94%AF%E4%B8%8A%E9%9D%A2%E5%BE%8C%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>記得要先切換到<code>elephant分支</code>(要rebase到別人的分支)!<ul> <li>$ <code>git checkout elephant</code> </li> </ul> </li> <li>$ <code>git rebase zebra</code>: 將<code>elephant分支</code>rebase到<code>zebra分支</code>上面</li> <li><img alt="git rebase 練習畫面_將elephant分支rebase到zebra分支上面後的圖解說明" src=../../assets/pics/git/git%20rebase%20%E7%B7%B4%E7%BF%92%E7%95%AB%E9%9D%A2_%E5%B0%87elephant%E5%88%86%E6%94%AFrebase%E5%88%B0zebra%E5%88%86%E6%94%AF%E4%B8%8A%E9%9D%A2%E5%BE%8C%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>$ <code>git rebase -i &lt;HEAD的相對位置&gt;</code></li> <li>例如: $ <code>git rebase -i HEAD~3</code></li> <li>可以先在互動式模式編輯哪些<code>Commit物件</code>要被<code>Rebase</code><ul> <li>可以使用像是<code>pick</code>、<code>edit</code>、<code>squash</code>、<code>drop</code> 等相關Git指令來編輯這些<code>Commit物件</code> </li> </ul> </li> <li><code>-i</code> (=&gt; <code>--interactive</code>): 利用互動式模式來"預先"編輯要<code>被rebased的那些Commit物件</code></li> <li><img alt="git rebase -i 參考動圖1" src=../../assets/pics/git/git%20rebase%20-i%20%E5%8F%83%E8%80%83%E5%8B%95%E5%9C%961.gif><br> 參考圖片出處: <a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR22RpLWxsCk1qKLdJynK4BCMyD5FSTvRHta8GvAyJO2ALi4WObsdQ-UWNU">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR22RpLWxsCk1qKLdJynK4BCMyD5FSTvRHta8GvAyJO2ALi4WObsdQ-UWNU</a></li> <li><img alt="git rebase -i 參考動圖2" src=../../assets/pics/git/git%20rebase%20-i%20%E5%8F%83%E8%80%83%E5%8B%95%E5%9C%962.gif><br> 參考圖片出處: <a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR22RpLWxsCk1qKLdJynK4BCMyD5FSTvRHta8GvAyJO2ALi4WObsdQ-UWNU">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1?fbclid=IwAR22RpLWxsCk1qKLdJynK4BCMyD5FSTvRHta8GvAyJO2ALi4WObsdQ-UWNU</a></li> <li>$ <code>git rebase</code> 是一種會修改到歷史紀錄的指令,盡量不要隨便對已經推出去給別人內容進行<code>rebase</code>,這樣很容易造成其他人的困擾</li> <li>用$ <code>git rebase</code> 的方式合併分支 &amp; 用$ <code>git merge</code> 的方式合併分支,有一個很明顯的差別是用<code>Rebase方式</code>合併分支的話,Git並不會特別做出一個專門用來合併分支的<code>Commit物件</code></li> <li>$ <code>git rebase</code> 的原理其實是做多次"Apply"到<code>新的基準點branch</code>指向的<code>Commit物件</code>上</li> <li><img alt="git rebase的原理_圖解說明" src=../../assets/pics/git/git%20rebase%E7%9A%84%E5%8E%9F%E7%90%86_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://gitbook.tw/chapters/branch/merge-with-rebase.html>https://gitbook.tw/chapters/branch/merge-with-rebase.html</a></li> <li>用<code>Rebase合併分支</code>過後,原來舊的那個分支原本所用到的那些Commit物件,並"不會立即被Git刪除"; 只是因為那些<code>Commit物件</code>沒有<code>分支(branch)</code>指向他們,所以如果我們也沒特別去記下這些<code>Commit物件的id</code>的話,這些<code>Commit物件</code>就會慢慢地被邊緣化,直到有一天被Git的內建資源回收機制帶走</li> <li>其實誰Rebase誰以結果來看是沒什麼差別的,但以歷史紀錄來說的話,被rebase的分支會寫在後面</li> <li>想取消合併分支的話,有以下兩種方式</li> <li>如果是用 $ <code>git merge</code> 來合併分支的話: 用 $ <code>git reset HEAD~2 --hard</code> =&gt; 也就是拆掉這個合併的Commit物件,大家就會退回到合併前的狀態</li> <li>如果是用 $ <code>git rebase</code> 來合併分支的話,因為這個方法Git並不會特別做出一個<code>Commit物件</code>來合併分支,所以不能用上述的方法;但可以用以下兩種方式來取消合併分支<ul> <li>先檢視目前的<code>Reflog紀錄</code></li> <li>$ <code>git reflog</code><ul> <li><img alt="透過git reflog來還原到Rebase分支前的狀態" src=../../assets/pics/git/%E9%80%8F%E9%81%8Egit%20reflog%E4%BE%86%E9%82%84%E5%8E%9F%E5%88%B0Rebase%E5%88%86%E6%94%AF%E5%89%8D%E7%9A%84%E7%8B%80%E6%85%8B.png></li> <li>找出對應到最久以前的 <code>rebase關鍵字</code>的前一次<code>Commit物件</code>的id</li> <li>以這個例子是: <code>ce76004</code>這個<code>Commit物件id</code></li> </ul> </li> <li>用 $ <code>git reset &lt;要回到過去的哪個Commit物件id&gt; --hard</code></li> <li>這樣就可以回到<code>Rebase</code>以前的狀態了</li> <li>先檢視目前的<code>ORIG_HEAD</code>指向的<code>Commit物件的id</code></li> <li>可先參考<a href=#orig_head是什麼><code>ORIG_HEAD</code>是什麼?</a></li> <li>$ <code>cat .git/ORIG_HEAD</code>: <code>回傳Git危險操作以前的</code>ORIG_HEAD<code>指向的</code>Commit物件`的id</li> <li><img alt="git reset ORIG_HEAD --hard 來回到危險操作以前的ORIG_HEAD指向的Commit物件的SHA-1值_統整" src=../../assets/pics/git/git%20reset%20ORIG_HEAD%20--hard%20%E4%BE%86%E5%9B%9E%E5%88%B0%E5%8D%B1%E9%9A%AA%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%89%8D%E7%9A%84ORIG_HEAD%E6%8C%87%E5%90%91%E7%9A%84Commit%E7%89%A9%E4%BB%B6%E7%9A%84SHA-1%E5%80%BC_%E7%B5%B1%E6%95%B4.gif></li> </ul> </li> <li>使用<code>Rebase</code>方式來合併分支的優缺點分析</li> <li>好處1: 不會特別產生一個為了合併分支的<code>Commit物件</code></li> <li>好處2: 合併的歷史順序可以自由決定(依照<code>誰Rebase誰</code>而定)</li> <li>缺點1: 相對來說,比起<code>Merge</code>方式來合併分支,並沒有那麼直覺</li> <li>缺點2: 如果一個不小心可能會弄壞掉而且還不知道該怎麼<code>Reset</code>回來</li> <li>建議: 可以在還沒推出去前(<code>Push</code>),如果覺得<code>Commit物件</code>們太凌亂or瑣碎,可以先用<code>Rebase合併分支的方式</code>來整理這些<code>Commit物件</code>,再推出去</li> <li>提醒: <code>Rebase</code>等於是修改歷史紀錄,如果修改已經推出去(<code>Push</code>)的歷史紀錄可能會造成其他人的困擾,所以如果是已經推出去(<code>Push</code>)的內容,非必要盡量不要使用<code>Rebase</code></li> <li>$ <code>git rebase -i &lt;過去的一個Commit物件id&gt;</code></li> <li>可以使用像是<code>pick</code>、<code>edit</code>、<code>squash</code>、<code>drop</code> 等相關Git指令來編輯這些<code>Commit物件</code></li> <li><code>Rebase指令</code>的互動模式(<code>-i</code>)也可以用來編輯過去的所有<code>Commit物件</code></li> <li><code>-p</code> (=&gt; <code>--pick</code>): use commit</li> <li><code>-r</code> (=&gt; <code>reword</code>): use commit, but edit the commit message(當想修改過去歷史紀錄中的<code>commit message</code>時)</li> <li><code>-e</code> (=&gt; <code>edit</code>): use commit, but stop for amending(適用以下情境)<ul> <li>當想把一個<code>commit紀錄</code>拆解成多個<code>commit紀錄</code>時</li> <li>當想在某些commit之間再加新的<code>commit紀錄</code></li> <li>當想要刪除某幾個commit紀錄</li> <li>當想要調整過去commit紀錄的順序</li> <li>Git會再重新執行一次<code>Rebase</code>時,停在<code>edit</code>那行的<code>Commit物件</code>上</li> <li>這時Git的狀態應該會類似這樣</li> <li><img alt="git rebase -i後的edit選項,Git停下來要做修改該Commit物件時的狀態的圖解說明" src=../../assets/pics/git/git%20rebase%20-i%E5%BE%8C%E7%9A%84edit%E9%81%B8%E9%A0%85%2CGit%E5%81%9C%E4%B8%8B%E4%BE%86%E8%A6%81%E5%81%9A%E4%BF%AE%E6%94%B9%E8%A9%B2Commit%E7%89%A9%E4%BB%B6%E6%99%82%E7%9A%84%E7%8B%80%E6%85%8B%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://gitbook.tw/chapters/rewrite-history/split-one-commit-to-many-commits.html>https://gitbook.tw/chapters/rewrite-history/split-one-commit-to-many-commits.html</a></li> <li>這時Git會詢問要如何修改這個<code>Commit物件</code>,通常這時候要先把要做"修改"的<code>Commit物件</code>的調整好,接著繼續<code>Rebase</code>下去</li> <li>$ <code>git commit --amend</code>: "修改"該<code>Commit物件</code></li> <li><code>$ git rebase --continue</code>: 繼續<code>Rebase</code>下去</li> <li>如果這時候不是要修改該<code>Commit物件</code>,而是想要將該<code>Commit物件</code>拆分成兩個<code>Commit物件</code>的話,可以用<code>Reset</code>指令來完成</li> <li>可先參考<a href=#如果不小心使用-git-reset---hard-模式能救回來嗎>如果不小心使用$ <code>git reset --hard</code> 模式,能救回來嗎?</a></li> <li>$ <code>git reset HEAD^</code> : 回到<code>HEAD</code>目前指向的<code>Commit物件</code>的前一次<code>commit紀錄</code>上</li> <li>$ <code>git status</code>: 先檢視一下目前的Git狀態<ul> <li><img alt="git rebase -i 互動模式的edit選項,Rebase到一半的Git狀態圖解畫面說明" src=../../assets/pics/git/git%20rebase%20-i%20%E4%BA%92%E5%8B%95%E6%A8%A1%E5%BC%8F%E7%9A%84edit%E9%81%B8%E9%A0%85%2CRebase%E5%88%B0%E4%B8%80%E5%8D%8A%E7%9A%84Git%E7%8B%80%E6%85%8B%E5%9C%96%E8%A7%A3%E7%95%AB%E9%9D%A2%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://gitbook.tw/chapters/rewrite-history/split-one-commit-to-many-commits.html>https://gitbook.tw/chapters/rewrite-history/split-one-commit-to-many-commits.html</a></li> </ul> </li> <li>可以看到<code>cat3.html</code> &amp; <code>cat4.html</code>都被拆出來放在工作目錄並且是處於<code>Untracked File</code>狀態</li> <li>接著就按照平常的流程($ <code>git add &lt;一個檔案的檔名&gt;</code> + <code>$ git commit -m "xxxx"</code>),就可以拆解成兩次<code>commit紀錄</code>出來了</li> <li>最後還是要記得目前仍依然處於<code>Rebase狀態</code>,所以要讓<code>Rebase流程</code>繼續跑完才算完成喔!<ul> <li>$ <code>git rebase --continue</code> </li> </ul> </li> </ul> </li> <li><code>-s</code> (=&gt; <code>squash</code>): use commit, but meld into previous commit(當想把多個<code>commit紀錄</code>合併成一個<code>c</code>ommit紀錄`時)</li> <li><code>-d</code> (=&gt; <code>drop</code>): remove commit</li> <li>注意! $ <code>git rebase -i</code> 與 $ <code>git log</code> 顯示commit紀錄的順序是相反的,若都是"從上到下"檢視的話</li> <li>$ <code>git rebase -i</code>: 從舊-&gt;新</li> <li>$ <code>git log</code>: 從新-&gt;舊</li> <li>$ <code>git reflog</code>: 從新-&gt;舊</li> <li><img alt="git rebase -i <過去的Commit物件id>,利用Rebase互動模式來編輯過去的commit message的圖解說明" src=../../assets/pics/git/git%20rebase%20-i%20%3C%E9%81%8E%E5%8E%BB%E7%9A%84Commit%E7%89%A9%E4%BB%B6id%3E%2C%E5%88%A9%E7%94%A8Rebase%E4%BA%92%E5%8B%95%E6%A8%A1%E5%BC%8F%E4%BE%86%E7%B7%A8%E8%BC%AF%E9%81%8E%E5%8E%BB%E7%9A%84commit%20message%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li><code>情境說明</code></li> <li>$ <code>git rebase -i &lt;ca7a70e&gt;</code></li> <li><code>ca7a70e</code>: 為專案最初始的<code>Commit物件的id</code></li> <li>找到要編輯<code>commit message</code>的<code>Commit物件</code>,將<code>pick</code>修改為<code>reword</code>,就會跳進去該<code>Commit物件</code>裡面,可以利用 Vim模式 來編輯該物件的<code>commit message</code>後,並存檔 &amp; 離開 即可</li> <li><img alt="在Rebase互動模式中利用reword來編輯過去的commit message" src=../../assets/pics/git/%E5%9C%A8Rebase%E4%BA%92%E5%8B%95%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%88%A9%E7%94%A8reword%E4%BE%86%E7%B7%A8%E8%BC%AF%E9%81%8E%E5%8E%BB%E7%9A%84commit%20message.png></li> <li>提醒: 經過<code>Rebase模式</code>修改後,因為前後要接的Commit物件都不同(其實時間也不同),所以會重新計算並做出一顆新的Commit物件; <br> 而因為在Git歷史紀錄上的這兩顆Commit物件被換掉了,在它們兩個之後的一整串Commit物件全部都必須做出新的Commit物件出來替代舊的Commit物件們</li> <li>相關觀念可參考</li> <li><a href=#分支branch操作>分支(branch)操作</a>的<br> $ <code>git rebase</code> 的原理其實是做多次"Apply"到<code>新的基準點branch</code>指向的<code>Commit物件</code>上原理 &amp; 圖解說明</li> <li><a href=#sha-1安全散列演算法-介紹>SHA-1(安全散列演算法) 介紹</a>的<br> <code>Blob</code>物件的<code>SHA-1</code>值計算公式 章節</li> <li>提醒: 在執行<code>Rebase操作</code>時,要多注意"相依性問題", 否則一定會出問題的</li> <li><code>情境說明</code></li> <li>某次<code>commit紀錄</code>修改了<code>zebra.html</code>,結果卻不小心把這次<code>commit紀錄</code>移動到建立<code>zebra.html</code>的那次<code>commit紀錄</code>之前</li> <li>刪除了某次建立<code>sheep.html</code>的<code>commit紀錄</code>,但後面的<code>commit紀錄</code>都需要用到<code>sheep.html</code>這個檔案</li> </ul> <h4 id=commit_3>該如何回復到上一次<code>commit紀錄</code>的狀態?<a class=headerlink href=#commit_3 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git revert HEAD --no-edit</code>: 會取消最後一次的<code>commit紀錄</code>,並"回復"到前一次<code>commit紀錄</code>的狀態</li> <li><code>--no-edit</code>: 指定<code>Revert</code>指令不要開啟<code>commit message</code>編輯器</li> <li><code>情境說明</code></li> <li>編輯<code>pig.html</code>,並新增"abc"字串</li> <li><img alt="git revert 練習_編輯pig.html檔案" src=../../assets/pics/git/git%20revert%20%E7%B7%B4%E7%BF%92_%E7%B7%A8%E8%BC%AFpig.html%E6%AA%94%E6%A1%88.png></li> <li><code>git revert HEAD --no-edit</code>: 會取消最後一次的<code>commit紀錄</code>,並回復到<code>HEAD</code>的前一次commit紀錄</li> <li><img alt="git revert練習_Revert後abc字串不見了" src=../../assets/pics/git/git%20revert%E7%B7%B4%E7%BF%92_Revert%E5%BE%8Cabc%E5%AD%97%E4%B8%B2%E4%B8%8D%E8%A6%8B%E4%BA%86.png></li> <li>透過Sourcetree可以發現,Git會為了<code>Revert操作</code>,新增一個<code>Commit物件</code></li> <li><img alt="Sourcetree檢視git revert HEAD --no-edit執行後的狀況_圖解說明" src=../../assets/pics/git/Sourcetree%E6%AA%A2%E8%A6%96git%20revert%20HEAD%20--no-edit%E5%9F%B7%E8%A1%8C%E5%BE%8C%E7%9A%84%E7%8B%80%E6%B3%81_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>那要如何取消<code>Revert</code>呢? 有以下2種方法</li> <li>$ <code>git revert HEAD --no-edit</code>: 這樣一來剛剛被刪除的<code>pig.html</code>中的"abc"字串又復活了; 但同時Git又會新增一個<code>Revert_"Revert" xxxxx</code> 的<code>Commit物件</code>,會造成<code>Commit物件</code>越來越多</li> <li><img alt=取消Revert操作會產生Revert_Revert的Commit物件 src=../../assets/pics/git/%E5%8F%96%E6%B6%88Revert%E6%93%8D%E4%BD%9C%E6%9C%83%E7%94%A2%E7%94%9FRevert_Revert%E7%9A%84Commit%E7%89%A9%E4%BB%B6.png> </li> <li>$ <code>git reset HEAD^ --hard</code>: 適用於直接放棄<code>HEAD</code>的前一次<code>commit紀錄</code>的所有操作(包括工作目錄 和 暫存區)</li> <li>可參考 <a href=#如果想重新編輯剛才的commit>如果想重新編輯剛才的commit</a></li> <li>較推薦此作法!</li> <li><code>Revert指令</code>的建議使用情境</li> <li>如果是個人開發的專案,其實可以直接用<code>Reset</code>切回去就好</li> <li>但如果是多人共同協作的專案,就不一定有機會可以使用<code>Reset</code>指令,這時候就可以用<code>Revert</code>指令來做出一個"取消"的<code>Commit物件</code>; 這樣對其他人來說也不算是"修改歷史",只是建立一個跟某個<code>commit紀錄</code>反向的操作的<code>Commit物件</code>而已</li> </ul> </li> </ul> <hr> <h3 id=_4>觀念介紹<a class=headerlink href=#_4 title="Permanent link">&para;</a></h3> <blockquote> <p><code>The HEAD</code>: HEAD is the pointer to the current branch reference, which is in turn a pointer to the last commit made on that branch. That means HEAD will be the parent of the next commit that is created. It’s generally simplest to think of HEAD as the snapshot of your last commit on that branch.<br> <code>ORIG_HEAD</code>: Git在危險操作以前,會先自動記錄當下<code>HEAD</code>指向的<code>Commit物件的id</code><br> <code>git branch</code> - List, create, or delete branches<br> <code>git cat-file</code> - Provide content or type and size information for repository object<br> <code>git count-objects</code> - Count unpacked number of objects and their disk consumption<br> <code>git tag</code> - Create, list, delete or verify a tag object signed with GPG<br> <code>git show</code> - Show various types of objects<br> <code>git prune</code> - Prune all unreachable objects from the object database<br></p> </blockquote> <h4 id=git_7>Git 其實是一種分散式的版本控制系統<a class=headerlink href=#git_7 title="Permanent link">&para;</a></h4> <ul> <li>Git是一種分散式的版本控制系統,而所謂的"版本控制系統"就是指會幫你記錄所有的狀態變化,隨時可以切換到過去某個版本的狀態</li> </ul> <h4 id=git_8>Git 的優點<a class=headerlink href=#git_8 title="Permanent link">&para;</a></h4> <ul> <li>Git的優點</li> <li>免費.開源</li> <li>Git是記錄檔案內容的快照(snapshot),而不是記錄版本之間的差異,它可以讓Git更快速地切換版本</li> <li>Git是一款分散式的版控系統(Distributed Version Control),雖然也會有共同的伺服器,但即使在沒有伺服器或是沒有網路的環境,依舊可以使用Git來進行版控,待伺服器恢復正常運作或是在有網路的環境後再同步,不會受影響</li> <li>註: Git和SVN相比,最大的不同點就是,Git可以在local端做一些修改,然後commit到本地的版本庫,最後push到伺服器; 而SVN只要一commit,更改就已經提交到伺服器了</li> </ul> <h4 id=git-snapshot>Git 是用快照(snapshot)在做版本控制的<a class=headerlink href=#git-snapshot title="Permanent link">&para;</a></h4> <ul> <li>Git在每次版本變化的時候,有點像拍照(snapshot)一樣,Git會更新並記錄整個目錄跟檔案的樹狀結構</li> </ul> <h4 id=git-blobtreecommittag>Git 的四大物件(<code>Blob</code>,<code>Tree</code>,<code>Commit</code>,<code>Tag</code>)觀念介紹<a class=headerlink href=#git-blobtreecommittag title="Permanent link">&para;</a></h4> <ul> <li>Git的四大物件結構: 在<code>.git/</code> 的資料結構裡面會有</li> <li>Blob物件<ul> <li><code>情境說明</code> </li> <li>當檔案被加入暫存區(staging area)時,Git便會在<code>.git/</code>目錄裡產生一個<code>Blob</code>(Binary large object)物件,並且依照它的"規則"擺放到它的目錄裡,這個<code>Blob物件</code>是用來存放該檔案的"內容"</li> <li>接下來,就會到 <code>.git/objects/</code>目錄裡存放該檔案,Git會用<code>SHA-1</code>的40個字中的<code>前2個字</code>作為目錄,剩餘的38個就是檔案名稱</li> <li><img alt=檢視.git/objects/中的Blob物件的SHA-1值-新 src=../../assets/pics/git/%E6%AA%A2%E8%A6%96.git%3Aobjects%3A%E4%B8%AD%E7%9A%84Blob%E7%89%A9%E4%BB%B6%E7%9A%84SHA-1%E5%80%BC-%E6%96%B0.gif></li> <li>透過$ <code>git cat-file</code>來檢視Git repository內各物件的 <code>值</code> or <code>型態</code> or <code>大小</code> or <code>相關詳細資訊</code></li> <li>-t: 顯示該物件的型態(type)</li> <li>-p: 顯示該物件的內容(content)</li> <li>-s: 顯示該物件的大小(size)</li> <li><img alt="git cat-file檢視該檔案的型態or內容or大小圖解說明" src=../../assets/pics/git/git%20cat-file%E6%AA%A2%E8%A6%96%E8%A9%B2%E6%AA%94%E6%A1%88%E7%9A%84%E5%9E%8B%E6%85%8Bor%E5%85%A7%E5%AE%B9or%E5%A4%A7%E5%B0%8F%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>統整: </li> <li>步驟一: 當使用$ <code>git add</code>把檔案加入至暫存區時,Git會根據這個物件的"內容"計算出<code>SHA-1</code>值</li> <li>步驟二: Git接著會用這個<code>SHA-1</code>值的前<code>2</code>個字當作<code>目錄名稱</code>,後38個字當作檔案名稱;接著Git會把目錄及檔案建立在<code>.git/objects/</code> 目錄裡面</li> <li>步驟三: 該檔案的內容則是Git使用壓縮演算法,把原本的"內容"壓縮之後的結果</li> <li>補充: <code>Blob物件</code>的<code>檔名</code>是由<code>SHA-1</code>演算法決定的,Blob物件的<code>內容</code>則是壓縮演算法決定的</li> </ul> </li> <li>Tree物件<ul> <li><code>Tree物件</code>會指向<code>某個</code>或是<code>某些Blob物件</code>,或是其他<code>Tree物件</code></li> <li><img alt=Git官方網站提供的Tree物件和Blob物件的關係圖解說明 src=../../assets/pics/git/Git%E5%AE%98%E6%96%B9%E7%B6%B2%E7%AB%99%E6%8F%90%E4%BE%9B%E7%9A%84Tree%E7%89%A9%E4%BB%B6%E5%92%8CBlob%E7%89%A9%E4%BB%B6%E7%9A%84%E9%97%9C%E4%BF%82%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-Objects>https://git-scm.com/book/zh-tw/v2/Git-Internals-Git-Objects</a> </li> <li><img alt=Tree物件介紹 src=../../assets/pics/git/Tree%E7%89%A9%E4%BB%B6%E4%BB%8B%E7%B4%B9.png></li> <li>統整:</li> <li>步驟一: <code>檔案</code>在Git裡會以<code>Blob物件</code>的方式存放</li> <li>步驟二: <code>目錄</code>及檔案名稱會以<code>Tree物件</code>的形式存放</li> <li>步驟三: <code>Tree物件</code>會指向<code>某個</code>或是<code>某些Blob物件</code>,或是其他<code>Tree物件</code></li> </ul> </li> <li>Commit物件<ul> <li>通常包含以下 4 項資訊 </li> <li>某個<code>Tree物件</code></li> <li>parent: 會指向前一次的Commit物件</li> <li>作者跟這次commit的人&amp;該次的commit時間</li> <li>本次的commit訊息($ <code>git commit -m</code>)</li> <li><img alt=Git官方網站提供的Commit物件與Tree物件和Blob物件的關係圖解說明 src=../../assets/pics/git/Git%E5%AE%98%E6%96%B9%E7%B6%B2%E7%AB%99%E6%8F%90%E4%BE%9B%E7%9A%84Commit%E7%89%A9%E4%BB%B6%E8%88%87Tree%E7%89%A9%E4%BB%B6%E5%92%8CBlob%E7%89%A9%E4%BB%B6%E7%9A%84%E9%97%9C%E4%BF%82%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處: <a href=https://git-scm.com/book/en/v2/Git-Internals-Git-Objects>https://git-scm.com/book/en/v2/Git-Internals-Git-Objects</a></li> <li>統整<code>Commit物件</code>的規則:</li> <li><code>Commit物件</code>會指向某個<code>Tree物件</code></li> <li><code>Tree物件</code>會指向<code>某個</code>或是<code>某些Blob物件</code>,或是其他<code>Tree物件</code></li> <li>除了第一個<code>Commit物件</code>以外,所有的<code>Commit物件</code>都會指向它的前一次的<code>Commit物件</code></li> </ul> </li> <li>Tag物件<ul> <li>$ <code>git tag -a wow -m "Tag物件 annotated tag 練習"</code></li> <li>$ <code>git cat-file -t &lt;</code>Tag物件<code>的SHA-1值&gt;</code></li> <li><img alt=Tag物件介紹 src=../../assets/pics/git/Tag%E7%89%A9%E4%BB%B6%E4%BB%8B%E7%B4%B9.png></li> <li>統整:</li> <li><code>Tag物件</code>中的有附註Tag(Annotated Tag)會指向某個<code>Commit物件</code></li> </ul> </li> <li>Git四大物件(<code>Blob</code>,<code>Tree</code>,<code>Commit</code>,<code>Tag</code>)觀念整合:<ul> <li>把檔案加入Git之後,檔案的內容會被轉成<code>Blob物件</code>儲存</li> <li>目錄以及檔名會存放在<code>Tree物件</code>內,<code>Tree物件</code>會指向<code>Blob物件</code>,或是其它的<code>Tree物件</code></li> <li><code>Commit物件</code>會指向某個<code>Tree物件</code>;除了第一個<code>Commit物件</code>以外,其它的commit都會指向前一次的<code>Commit物件</code></li> <li><code>Tag物件</code>(Annotated Tag)會指向某個<code>Commit物件</code></li> <li><code>分支</code>(branch)雖然不屬於四個物件之一,但它會指向某個<code>Commit物件</code></li> <li>當開始往Git Server上推送之後,在 <code>.git/refs/</code> 底下就會多出一個 <code>remote/目錄</code>,裡面放的是遠端的分支,基本上跟本地的分支是差不多的概念,同樣也會指向某個<code>Commit物件</code></li> <li><img alt="透過檢視.git/refs/remotes/ 來看遠端分支有哪些" src=../../assets/pics/git/%E9%80%8F%E9%81%8E%E6%AA%A2%E8%A6%96.git%3Arefs%3Aremotes%3A%20%E4%BE%86%E7%9C%8B%E9%81%A0%E7%AB%AF%E5%88%86%E6%94%AF%E6%9C%89%E5%93%AA%E4%BA%9B.png> </li> <li><code>HEAD</code>也不屬於Git四大物件之一,它會指向某個<code>分支</code>(branch)</li> </ul> </li> </ul> <h4 id=git-count-objects>$ <code>git count-objects</code>: 可以檢視目前有多少物件和用掉多少儲存空間<a class=headerlink href=#git-count-objects title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git count-objects</code>: 可以檢視目前有多少物件和用掉多少儲存空間</li> <li><img alt="git count-objects可以檢視目前有多少物件和用掉多少儲存空間的圖解說明" src=../../assets/pics/git/git%20count-objects%E5%8F%AF%E4%BB%A5%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8D%E6%9C%89%E5%A4%9A%E5%B0%91%E7%89%A9%E4%BB%B6%E5%92%8C%E7%94%A8%E6%8E%89%E5%A4%9A%E5%B0%91%E5%84%B2%E5%AD%98%E7%A9%BA%E9%96%93%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li><code>-v</code> (=&gt; <code>--verbose</code>): 顯示這個Git管控的專案中所有物件的更多詳細資訊</li> <li><code>-H</code> (=&gt; <code>--human-readable</code>): 將所有在這個Git管控的專案中所有物件所佔用的儲存空間用人類可閱讀的格式來顯示(MB)</li> </ul> <h4 id=git_9>在使用Git時,指令要在正確的目錄下才能正常運作<a class=headerlink href=#git_9 title="Permanent link">&para;</a></h4> <ul> <li>在使用Git時,指令要在正確的目錄下才能正常運作</li> </ul> <h4 id=gitstaging-areaindex>在Git術語中,暫存區(staging area)=索引(index)<a class=headerlink href=#gitstaging-areaindex title="Permanent link">&para;</a></h4> <ul> <li>暫存區(Staging Area)又可稱為索引(index)</li> </ul> <h4 id=git-working-directorystaging-arearepository>Git 世界裡的的三大區域---<code>工作目錄(working directory)</code>,<code>暫存區(staging area)</code>,<code>儲存庫(repository)</code><a class=headerlink href=#git-working-directorystaging-arearepository title="Permanent link">&para;</a></h4> <ul> <li>在Git裡,主要可以分成三個區域,透過不同的git指令可以把檔案移動往不同的區域</li> <li>工作目錄(Working Directory)</li> <li>暫存區域(Staging Area) or (index)</li> <li>儲存庫(Repository)</li> <li><img alt=工作目錄_暫存區_儲存庫的關係圖解說明 src=../../assets/pics/git/%E5%B7%A5%E4%BD%9C%E7%9B%AE%E9%8C%84_%E6%9A%AB%E5%AD%98%E5%8D%80_%E5%84%B2%E5%AD%98%E5%BA%AB%E7%9A%84%E9%97%9C%E4%BF%82%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/ >https://gitbook.tw/</a></li> </ul> <h4 id=git-add-git-commit>為什麼每次都要先$ <code>git add</code> 再 $ <code>git commit</code><a class=headerlink href=#git-add-git-commit title="Permanent link">&para;</a></h4> <ul> <li>可以想像你有一個倉庫,倉庫門口有個小廣場,這個廣場的概念就像跟暫存區一樣,你把要存放到倉庫的貨物先放到這邊($ <code>git add</code>),然後等收集的差不多了就可以打開倉庫門,把放在廣場上的貨物送進倉庫裡($ <code>git commit -m</code>,並記錄下來這批貨是什麼用途的? &amp; 誰送來的?)</li> </ul> <h4 id=gitid-sha-1>Git物件的id是怎麼計算出來的? (<code>SHA-1演算法</code>)<a class=headerlink href=#gitid-sha-1 title="Permanent link">&para;</a></h4> <ul> <li>在Git的Commit物件裡每串看起來像亂碼的文字,都是透過SHA-1演算法計算出來的結果,是一種重複率極低的演算法;Git使用這樣的字串作為識別,每個Commit物件都有一個這樣的值,你可以把它想像成是每個Commit物件的身分證字號,不會重複</li> </ul> <h4 id=head><code>HEAD</code>是什麼?<a class=headerlink href=#head title="Permanent link">&para;</a></h4> <ul> <li><code>HEAD</code> 是一個指標,會指向某一個分支,我們通常可以把<code>HEAD</code>當作"目前分支"來; 也可以在<code>.git/HEAD</code>這個檔案裡看到記錄著<code>HEAD</code>的內容</li> <li>$ <code>cat .git/HEAD</code>: 顯示目前<code>HEAD</code>指向的分支 <ul> <li><img alt=在.git/HEAD中檢視目前HEAD指向的分支 src=../../assets/pics/git/%E5%9C%A8.git%3AHEAD%E4%B8%AD%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8DHEAD%E6%8C%87%E5%90%91%E7%9A%84%E5%88%86%E6%94%AF.png></li> </ul> </li> <li>$ <code>cat .git/refs/&lt;分支名稱&gt;</code>: 檢視目前HEAD指向的分支的commit物件<ul> <li><img alt=檢視目前HEAD指向的分支的commit物件 src=../../assets/pics/git/%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8DHEAD%E6%8C%87%E5%90%91%E7%9A%84%E5%88%86%E6%94%AF%E7%9A%84commit%E7%89%A9%E4%BB%B6.png></li> </ul> </li> <li>當切換分支時,HEAD指向的分支也會轉變<ul> <li>$ <code>git branch</code>: 檢視目前所有的分支有哪些</li> <li>$ <code>git branch bird</code>: 建立一個新的分支名稱為<code>bird</code></li> <li>$ <code>git checkout bird</code>:切換到<code>bird</code>分支</li> <li>$ <code>cat .git/HEAD</code> : 檢視目前HEAD指向的是哪個分支名稱 //<blockquote> <p>ref: refs/heads/bird </p> </blockquote> </li> <li>總結: <code>.git/HEAD</code>的內容(<code>.git/refs/heads/&lt;目前所在分支的名稱&gt;</code>會隨著$ <code>git checkout &lt;分支名稱&gt;</code> 而改變)</li> </ul> </li> <li>補充: 在Git <code>v1.8.5</code> 之後的版本開始支援,可以用 <code>＠</code> 這個符號來代表<code>HEAD</code><ul> <li><code>情境說明</code> </li> <li>$ <code>git reset HEAD~2</code> = $ <code>git reset @~2</code></li> <li>$ <code>git reset HEAD^^</code>= $ <code>git reset @^^</code></li> <li>以上四種指令都是相同的意思,代表要回到目前的<code>HEAD指標</code>指向的<code>Commit物件</code>以前的<code>2次``commit紀錄</code>的那時候</li> <li>可參考<a href=#如果想重新編輯剛才的commit>如果想重新編輯剛才的commit</a></li> </ul> </li> </ul> <h4 id=orig_head><code>ORIG_HEAD</code>是什麼?<a class=headerlink href=#orig_head title="Permanent link">&para;</a></h4> <ul> <li><code>ORIG_HEAD</code> 是Git特別的一個紀錄點,這個紀錄點會自動記錄在"Git的危險操作"以前,當下的<code>HEAD</code>指向的<code>Commit物件的id</code></li> <li>Git的"危險操作"有: <code>merge</code>、<code>rebase</code>、<code>reset</code></li> <li>$ <code>cat .git/ORIG_HEAD</code><ul> <li><img alt=檢視ORIG_HEAD指向的Commit物件的SHA-1值 src=../../assets/pics/git/%E6%AA%A2%E8%A6%96ORIG_HEAD%E6%8C%87%E5%90%91%E7%9A%84Commit%E7%89%A9%E4%BB%B6%E7%9A%84SHA-1%E5%80%BC.png></li> </ul> </li> <li>可以檢視目前的 <code>ORIG_HEAD</code> 紀錄點是指向哪個<code>Commit物件</code></li> <li>$ cat <code>.git/ORIG_HEAD</code><ul> <li><img alt="透過cat .git/ORIG_HEAD 這個檔案來檢視在Git危險操作以前的那個ORIG_HEAD會指向哪個Commit物件" src=../../assets/pics/git/%E9%80%8F%E9%81%8Ecat%20.git%3AORIG_HEAD%20%E9%80%99%E5%80%8B%E6%AA%94%E6%A1%88%E4%BE%86%E6%AA%A2%E8%A6%96%E5%9C%A8Git%E5%8D%B1%E9%9A%AA%E6%93%8D%E4%BD%9C%E4%BB%A5%E5%89%8D%E7%9A%84%E9%82%A3%E5%80%8BORIG_HEAD%E6%9C%83%E6%8C%87%E5%90%91%E5%93%AA%E5%80%8BCommit%E7%89%A9%E4%BB%B6.png></li> </ul> </li> </ul> <h4 id=branch_1><code>分支(branch)</code>是什麼?<a class=headerlink href=#branch_1 title="Permanent link">&para;</a></h4> <ul> <li>在Git裡面,<code>分支(branch)</code>就像貼紙一樣,它會貼在某個<code>Commit物件</code>上,並且會隨著每次的commit跟著移動</li> <li>所以<code>HEAD</code>會指向一個<code>分支(branch)</code>,並且<code>分支</code>會指向一個<code>Commit物件</code><ul> <li>通常來說<code>HEAD</code>所指的那個<code>分支(branch)</code>,會跟著新的<code>Commit物件</code>前進(而<code>HEAD</code>也會跟著一起前進) </li> <li><img alt=git分支是什麼_圖解說明---by官方文件 src=../../assets/pics/git/git%E5%88%86%E6%94%AF%E6%98%AF%E4%BB%80%E9%BA%BC_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E---by%E5%AE%98%E6%96%B9%E6%96%87%E4%BB%B6.png> 參考圖片出處<a href=https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell>https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell</a> </li> </ul> </li> <li>當 $ <code>git checkout &lt;分支名稱orCommit物件&gt;</code>時,Git會依據當下的這個<code>Commit物件</code>來還原工作目錄(<code>working directory</code>)的內容,並參考 <code>.git/objects/</code> 目錄裡的內容像拎葡萄一樣整串從頭的地方拎起來,只要從源頭的<code>Commit物件</code>拎起來,整串內容都可以被拿出來<ul> <li><img alt="git checkout到過去的Commit物件造成Deatched HEAD的官方圖解說明" src=../../assets/pics/git/git%20checkout%E5%88%B0%E9%81%8E%E5%8E%BB%E7%9A%84Commit%E7%89%A9%E4%BB%B6%E9%80%A0%E6%88%90Deatched%20HEAD%E7%9A%84%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.gif> 參考圖片出處<a href=https://git-scm.com/docs/git-checkout>https://git-scm.com/docs/git-checkout</a></li> <li>注意! 這時候有可能會發生<code>Detached HEAD</code>的情況!</li> <li>當使用 $ <code>git checkout &lt;Commit物件的id&gt;</code> 後,該<code>Commit物件</code>剛好目前沒有分支(branch)指向它 </li> </ul> </li> <li>$ <code>git branch</code>: 檢視目前所有的分支有哪些<ul> <li><img alt="用git branch來檢視目前的分支(master)" src=../../assets/pics/git/%E7%94%A8git%20branch%E4%BE%86%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8D%E7%9A%84%E5%88%86%E6%94%AF%28master%29.gif> </li> </ul> </li> <li>$ <code>git branch bird</code>: 建立一個新的分支名稱為<code>bird</code><ul> <li><img alt="用git branch <新的分支名稱> 來新增新的分支" src=../../assets/pics/git/%E7%94%A8git%20branch%20%3C%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF%E5%90%8D%E7%A8%B1%3E%20%E4%BE%86%E6%96%B0%E5%A2%9E%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF.gif></li> </ul> </li> <li>$ <code>git checkout bird</code>: 切換到<code>bird</code>分支<ul> <li>當Git在切換分支 ($ <code>git checkout &lt;branch name&gt;</code>) 的時候會做以下兩件事情</li> <li>用該分支指向的那個<code>Commit物件</code>的內容來"更新"暫存區(staging area)以及工作目錄(working directory),<strong>當切換分支"之前"所做的修改內容仍會留在工作目錄(working directory)不受影響</strong></li> <li>同時<code>HEAD</code>也會跟著一起前進,指向剛剛切換過去的那個分支(branch)</li> </ul> </li> <li>$ <code>git branch -m bird fish</code>: 將<code>bird分支</code>更名為<code>fish分支</code><ul> <li><code>-m</code> (=&gt; <code>--move</code>): 移動or更名 <code>分支</code>(branch)和其相對應的<code>reflog</code></li> <li><img alt="git branch -m 修改分支名稱的圖解說明" src=../../assets/pics/git/git%20branch%20-m%20%E4%BF%AE%E6%94%B9%E5%88%86%E6%94%AF%E5%90%8D%E7%A8%B1%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.gif></li> </ul> </li> <li>$ <code>git branch -d fish</code>: 將<code>fish</code>分支刪除<ul> <li><code>-d</code> (=&gt; <code>--delete</code>): 刪除該分支</li> <li>補充: 只有目前所在的分支不能刪除,只要先$ <code>git checkout</code> 切換到別的分支後也可以刪除原本所在的那個分支(儘管是master分支)</li> <li><img alt="git branch -d 刪除分支後的圖解說明" src=../../assets/pics/git/git%20branch%20-d%20%E5%88%AA%E9%99%A4%E5%88%86%E6%94%AF%E5%BE%8C%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.gif></li> </ul> </li> <li>或是 $ <code>git branch -D fish</code>:強制將尚未合併(merged)的分支刪除<ul> <li><code>-D</code> = <code>-d</code> + <code>-f</code> (=&gt; <code>--delete --force</code> 的縮寫): 強制刪除該分支( 不管該分支是否已經合併(merged)到其上游分支(upstream branch) )</li> </ul> </li> <li>合併過後的分支,想刪除就可以刪除,因為分支只是一個<code>40</code>字元的檔案而已,它會標記出它目前是指向哪一個<code>Commit物件</code>; 所以<code>刪除分支</code>這個動作就像是把一張貼紙撕起來的概念而已,原來被這張貼紙貼著的東西並"不會"因此而不見</li> <li>在Git開分支其實很"便宜",因為<code>分支(branch)</code>其實就只是一張<code>40</code>字元(<code>某個Commit物件的SHA-1值</code>)的<code>貼紙</code>,而這個貼紙會指向它對應的<code>Commit物件的id</code></li> <li>可檢視 <code>.git/refs/heads/&lt;分支名稱&gt;</code> 這個檔案裡的內容就是該<code>分支(branch)</code>指向它對應的<code>Commit物件的id</code><ul> <li>$ <code>ls -al .git/refs/heads/</code></li> <li><img alt="檢視.git/refs/heads/ 來得知目前有哪些分支" src=../../assets/pics/git/%E6%AA%A2%E8%A6%96.git%3Arefs%3Aheads%3A%20%E4%BE%86%E5%BE%97%E7%9F%A5%E7%9B%AE%E5%89%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E6%94%AF.png> </li> <li><img alt="檢視.git/refs/heads/<分支名稱>裡面的檔案內容是該分支指向的Commit物件id" src=../../assets/pics/git/%E6%AA%A2%E8%A6%96.git%3Arefs%3Aheads%3A%3C%E5%88%86%E6%94%AF%E5%90%8D%E7%A8%B1%3E%E8%A3%A1%E9%9D%A2%E7%9A%84%E6%AA%94%E6%A1%88%E5%85%A7%E5%AE%B9%E6%98%AF%E8%A9%B2%E5%88%86%E6%94%AF%E6%8C%87%E5%90%91%E7%9A%84Commit%E7%89%A9%E4%BB%B6id.png></li> </ul> </li> <li>如果把 <code>.git/refs/heads/</code> 目錄裡面的其中一個分支刪掉的話,就相當於刪除分支了<ul> <li>$ <code>rm .git/refs/heads/&lt;要刪除的分支名稱&gt;</code> </li> <li><img alt="rm .git/refs/heads/ 目錄裡面的其中一個分支就是相當於刪除該分支了" src=../../assets/pics/git/rm%20.git%3Arefs%3Aheads%3A%20%E7%9B%AE%E9%8C%84%E8%A3%A1%E9%9D%A2%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E5%80%8B%E5%88%86%E6%94%AF%E5%B0%B1%E6%98%AF%E7%9B%B8%E7%95%B6%E6%96%BC%E5%88%AA%E9%99%A4%E8%A9%B2%E5%88%86%E6%94%AF%E4%BA%86.png> </li> </ul> </li> <li>如果把 <code>.git/refs/heads</code> 目錄裡面的其中一個分支名稱改掉的話,就相當於修改分支名稱了<ul> <li>$ <code>mv .git/refs/heads/&lt;原分支名稱&gt; .git/refs/heads/&lt;新分支名稱&gt;</code></li> <li><img alt="mv .git/refs/heads/ 目錄裡面的其中一個分支名稱就是相當於修改該分支的名稱了" src=../../assets/pics/git/mv%20.git%3Arefs%3Aheads%3A%20%E7%9B%AE%E9%8C%84%E8%A3%A1%E9%9D%A2%E7%9A%84%E5%85%B6%E4%B8%AD%E4%B8%80%E5%80%8B%E5%88%86%E6%94%AF%E5%90%8D%E7%A8%B1%E5%B0%B1%E6%98%AF%E7%9B%B8%E7%95%B6%E6%96%BC%E4%BF%AE%E6%94%B9%E8%A9%B2%E5%88%86%E6%94%AF%E7%9A%84%E5%90%8D%E7%A8%B1%E4%BA%86.png></li> </ul> </li> <li>Git如何知道現在是在哪一個分支(branch)?</li> <li>可以透過Git指令 $ <code>git branch -l</code><ul> <li><code>-l</code> (=&gt; <code>--list</code>): 顯示目前有哪些分支(<code>branch</code>)</li> </ul> </li> <li>可以透過檢視 <code>.git/HEAD</code> 這個檔案,來得知HEAD指標目前指向的是哪一個分支(branch)<ul> <li>$ <code>cat .git/HEAD</code></li> <li><img alt="透過指令cat .git/HEAD 來檢視目前的HEAD指標是指向哪個分支" src=../../assets/pics/git/%E9%80%8F%E9%81%8E%E6%8C%87%E4%BB%A4cat%20.git%3AHEAD%20%E4%BE%86%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8D%E7%9A%84HEAD%E6%8C%87%E6%A8%99%E6%98%AF%E6%8C%87%E5%90%91%E5%93%AA%E5%80%8B%E5%88%86%E6%94%AF.png></li> <li>當切換分支(brach)時, .git/HEAD 的內容也會同時變動</li> <li>先 $ <code>git checkout &lt;另一個分支名稱&gt;</code></li> <li>再 $ <code>cat .git/HEAD</code></li> <li><img alt="透過git checkout後來檢視.git/HEAD的檔案內容也同時跟著變動且指向新的分支名稱" src=../../assets/pics/git/%E9%80%8F%E9%81%8Egit%20checkout%E5%BE%8C%E4%BE%86%E6%AA%A2%E8%A6%96.git%3AHEAD%E7%9A%84%E6%AA%94%E6%A1%88%E5%85%A7%E5%AE%B9%E4%B9%9F%E5%90%8C%E6%99%82%E8%B7%9F%E8%91%97%E8%AE%8A%E5%8B%95%E4%B8%94%E6%8C%87%E5%90%91%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF%E5%90%8D%E7%A8%B1.png></li> </ul> </li> </ul> <h4 id=detached-head><code>Detached HEAD</code> (斷頭) 是什麼?<a class=headerlink href=#detached-head title="Permanent link">&para;</a></h4> <ul> <li><code>Detached HEAD</code> (斷頭): 正常情況下,HEAD會指向某一個分支,而分支會指向某一個Commit物件。但有時候<code>HEAD</code>會發生"沒有辦法指到某個分支"的情況,這個狀態的<code>HEAD</code>就稱為 "<code>detached HEAD(斷頭)</code>"</li> <li>以下是3種常見的原因可能會造成<code>Detached HEAD</code>的狀態<ul> <li>使用 $ <code>git checkout &lt;Commit物件的id&gt;</code> 後,該<code>Commit物件</code>剛好目前沒有分支(branch)指向它</li> <li><img alt="git checkout切換到之前的Commit物件造成Detached HEAD官方圖解" src=../../assets/pics/git/git%20checkout%E5%88%87%E6%8F%9B%E5%88%B0%E4%B9%8B%E5%89%8D%E7%9A%84Commit%E7%89%A9%E4%BB%B6%E9%80%A0%E6%88%90Detached%20HEAD%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3.png> 參考圖片出處<a href=https://git-scm.com/docs/git-checkout>https://git-scm.com/docs/git-checkout</a></li> <li>$ <code>git rebase</code> 的過程其實也是不斷地處於<code>Detached HEAD</code>的狀態</li> <li>切換到某個遠端分支(remote branch)的時候</li> <li>例如: $ <code>git checkout -b test origin/test</code> </li> </ul> </li> <li>在 <code>Detached HEAD</code> 狀態下其實跟平常一樣操作Git,也可以進行commit,只是commit後,當下的那個<code>Commit物件</code>就只會有<code>HEAD</code>指標指向它,這時如果將<code>HEAD</code>指標切換到其他分支的話,這個<code>Commit物件</code>就很不容以被找回來了(除非你有記下這個<code>Commit物件</code>的id); 如果一直沒有人來找它的話,就要等到Git自動觸發資源回收機制來回收它了<ul> <li>這情況會有點類似於要從過去的<code>commit紀錄</code>,再長一個新的分支出來的情境</li> <li>可參考<a href=#如果想從過去的某次commit紀錄再長一個新的分支branch出來該如何做呢>如果想從過去的某次<code>commit紀錄</code>再長一個<code>新的分支(branch)</code>出來,該如何做呢?</a> </li> <li>這時如果想留下這個<code>Commit物件</code>的話,可以在該Commit物件上建立一個<code>分支(branch)</code>貼紙貼在上面</li> <li>$ <code>git branch &lt;要新增的分支名稱&gt; &lt;該Commit物件的id&gt;</code></li> <li>也可以建立新的分支後,直接切換到該分支上面</li> <li>$ <code>git checkout -b &lt;要新增的分支名稱&gt; &lt;該Commit物件的id&gt;</code></li> </ul> </li> <li>其實嚴格來說,當<code>HEAD</code>指標沒有指到某個"本地"分支的話,就會呈現<code>Detached HEAD</code>的狀態<ul> <li>$ <code>git branch -r</code>: 列出目前所有的<code>遠端分支(remote branch)</code></li> <li><code>-r</code> (=&gt; <code>--remotes</code>): 列出目前所有的<code>遠端分支(remote branch)</code></li> <li><img alt="git branch -r 檢視目前所有的遠端分支有哪些" src=../../assets/pics/git/git%20branch%20-r%20%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8D%E6%89%80%E6%9C%89%E7%9A%84%E9%81%A0%E7%AB%AF%E5%88%86%E6%94%AF%E6%9C%89%E5%93%AA%E4%BA%9B.gif></li> <li><code>情境說明</code></li> <li>如果要切換到遠端分支,而不希望呈現<code>Detached HEAD</code>狀態,可以使用以下指令<ul> <li>$ <code>git checkout -t origin/&lt;遠端分支名稱&gt;</code></li> <li><code>-t</code> (=&gt; <code>--track</code>): Git會在本機建立一個<code>追蹤分支</code>(tracking branch)</li> </ul> </li> <li>如果想要簡單一點也可以把前面的"origin"拿掉,並直接切換到<code>遠端分支</code>(remote branch)去<ul> <li>$ <code>git checkout &lt;遠端分支名稱&gt;</code> </li> </ul> </li> </ul> </li> <li>如何離開<code>Detached HEAD</code>狀態呢?<ul> <li>既然已經知道所謂的<code>Detached HEAD</code>狀態只是<code>HEAD</code>指標沒有指向任何分支所造成的,要脫離這個狀態,只要讓<code>HEAD</code>能指向任何一個<code>分支(branch)</code>就可以了</li> <li>例如: $ <code>git checkout master</code></li> <li>將目前的<code>HEAD指標</code>指向<code>master分支</code>就可以解除<code>Detached HEAD</code>的狀態了</li> </ul> </li> </ul> <h4 id=tag><code>Tag</code> (標籤) 是什麼?<a class=headerlink href=#tag title="Permanent link">&para;</a></h4> <ul> <li><code>Tag</code> (標籤): 是一個指向某一個<code>Commit物件</code>的"指標"</li> <li>可先參考<a href=#git-的四大物件blobtreecommittag觀念介紹>Git 的四大物件(<code>Blob</code>,<code>Tree</code>,<code>Commit</code>,<code>Tag</code>)觀念介紹</a></li> <li><code>Tag</code> (標籤)依據官方文件有以下3種適合作為的用途 &gt; Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. <ul> <li>軟體版本號(<code>release version</code>)</li> <li>個人使用(<code>private</code>)</li> <li>暫時標記用途(<code>temporary object labels</code>)</li> </ul> </li> <li><code>Tag</code> (標籤)可分為兩種形式<ul> <li><code>輕量標籤</code>(lightweight tag): 主要用來作為軟體版本號(<code>release version</code>)</li> <li><code>輕量標籤</code>(lightweight tag)會指向一個<code>Commit物件</code> </li> <li>$ <code>git tag &lt;輕量標籤的名稱&gt; &lt;要標記在哪個Commit物件上的id&gt;</code></li> <li>例如: $ <code>git tag refresh_hyperlink 19468c5</code>: 這樣Git就會在"19468c5"這個<code>Commit物件</code>上,建立一個<code>輕量標籤</code>(lightweight tag)叫做"refresh_hyperlink"</li> <li><img alt="git tag建立輕量標籤的圖解說明_統整" src=../../assets/pics/git/git%20tag%E5%BB%BA%E7%AB%8B%E8%BC%95%E9%87%8F%E6%A8%99%E7%B1%A4%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E_%E7%B5%B1%E6%95%B4.gif></li> <li><code>有附註標籤</code>(annotated tag): 用來作為個人使用(<code>private</code>)或是暫時標記用途(<code>temporary object labels</code>)</li> <li>注意: <code>有附註標籤</code>(annotated tag)會指向一個<code>Tag物件</code>,而這個<code>Tag物件</code>才會指向一個<code>Commit物件</code></li> <li>$ <code>git tag &lt;輕量標籤的名稱&gt; &lt;要標記在哪個Commit物件上的id&gt; -a -m "refresh_form_width"</code></li> <li>例如: $<code>git tag refresh_form_width 6894635 -a -m "有附註標籤的練習"</code>: 這樣Git就會在"6894635"這個<code>Commit物件</code>上,建立一個<code>有附註標籤</code>(annotated tag)叫做"refresh_form_width",並且新增一個tag message叫做"有附註標籤的練習"<ul> <li><code>-a</code> (=&gt; <code>--annotate</code>): 請Git幫忙建立一個<code>有附註標籤</code></li> <li><code>-m</code> (=&gt; <code>--message</code>): 建立一個<code>有附註標籤</code>的<code>訊息</code>(tag message)</li> </ul> </li> <li><img alt=新增有附註標籤的練習_統整 src=../../assets/pics/git/%E6%96%B0%E5%A2%9E%E6%9C%89%E9%99%84%E8%A8%BB%E6%A8%99%E7%B1%A4%E7%9A%84%E7%B7%B4%E7%BF%92_%E7%B5%B1%E6%95%B4.gif></li> <li><code>有附註標籤</code>(annotated tag)會有記錄更詳細的標籤相關資訊,通常會有以下資訊<ul> <li>誰貼的標籤?</li> <li>什麼時候貼的標籤?</li> <li>為什麼要貼這張標籤? </li> </ul> </li> <li>新增完標籤(<code>tag</code>)以後,可以用$ <code>git log --oneline</code>來檢視目前的<code>commit紀錄</code>的情況</li> <li><code>有附註標籤</code>(annotated tag)的訊息量也會比<code>輕量標籤</code>(lightweight tag)的訊息量多</li> <li>$ <code>git show &lt;標籤的名稱&gt;</code>: 可以用來檢視各種物件的型態<ul> <li>例如: $ <code>git show refresh_hyperlink</code> =&gt; 檢視<code>輕量標籤</code>(lightweight tag)的型態</li> <li><img alt="透過git show <輕量標籤的名稱> 來檢視輕量標籤目前的狀況_統整" src=../../assets/pics/git/%E9%80%8F%E9%81%8Egit%20show%20%3C%E8%BC%95%E9%87%8F%E6%A8%99%E7%B1%A4%E7%9A%84%E5%90%8D%E7%A8%B1%3E%20%E4%BE%86%E6%AA%A2%E8%A6%96%E8%BC%95%E9%87%8F%E6%A8%99%E7%B1%A4%E7%9B%AE%E5%89%8D%E7%9A%84%E7%8B%80%E6%B3%81_%E7%B5%B1%E6%95%B4.gif></li> <li>例如: $ <code>git show refresh_form_width</code> =&gt; 檢視<code>有附註標籤</code>(annotated tag)的型態</li> <li><img alt="透過git show <有附註標籤的名稱> 來檢視有附註標籤目前的狀況_統整" src=../../assets/pics/git/%E9%80%8F%E9%81%8Egit%20show%20%3C%E6%9C%89%E9%99%84%E8%A8%BB%E6%A8%99%E7%B1%A4%E7%9A%84%E5%90%8D%E7%A8%B1%3E%20%E4%BE%86%E6%AA%A2%E8%A6%96%E6%9C%89%E9%99%84%E8%A8%BB%E6%A8%99%E7%B1%A4%E7%9B%AE%E5%89%8D%E7%9A%84%E7%8B%80%E6%B3%81_%E7%B5%B1%E6%95%B4.gif></li> </ul> </li> <li>也可以到 <code>.git/refs/tags/</code> 目錄裡面,檢視所有的標籤</li> <li>$ <code>cat .git/refs/tags/&lt;標籤的名稱&gt;</code><ul> <li>如果是<code>輕量標籤</code>,會顯示該標籤(<code>tag</code>)指向的<code>Commit物件</code>的id</li> <li>如果是<code>有附註標籤</code>(annotated tag)會顯示其指向的<code>Tag物件</code>,而這個<code>Tag物件</code>才會指向一個<code>Commit物件</code>的id</li> </ul> </li> <li>刪除標籤</li> <li>$ <code>git tag -d &lt;標籤的名稱&gt;</code>: 將該<code>標籤</code>刪除<ul> <li>例如: $ <code>git tag -d refresh_hyperlink</code></li> <li><code>-d</code> (=&gt; <code>--delete</code>): 刪除已經存在的標籤</li> </ul> </li> </ul> </li> </ul> <h4 id=git-git-gc>Git的資源回收機制($ <code>git gc</code>)是怎麼運作的呢?<a class=headerlink href=#git-git-gc title="Permanent link">&para;</a></h4> <ul> <li>在Git裡,每當把檔案加入暫存區(staging area)時,Git便會根據"檔案內容"製作出<code>Blob物件</code>; 每當完成<code>commit</code>,便會跟著產生所需的<code>Tree物件</code>以及<code>Commit物件</code></li> <li>當物件越來越多,並達到觸發Git自動資源回收的機制(<code>Garbage Collection</code>)時,Git會利用這個機制來自動整理這些物件,同時也會把<code>Unreachable狀態</code>的物件清掉 </li> <li>可以先參考<a href=#git其實不是在做差異備份而是在為當時的專案建立快照snapshot>Git其實不是在做差異備份,而是在為當時的專案建立快照(snapshot)</a>的$ <code>git gc</code>章節</li> <li>Git的資源回收機制($ <code>git gc</code>)會自動回收掉<code>Unreachable狀態</code>的物件,但需要加上 <code>--prune=now</code> 來搭配使用,才會當下立即就生效<ul> <li>可以先參考<a href=#如何把一個檔案從git版控中真正的移除掉呢>如何把一個檔案從Git版控中真正的移除掉呢?</a></li> </ul> </li> <li>$ <code>git gc</code>其實會默默地呼叫$ <code>git prune</code>指令來清除<code>Unreachable物件</code>,但$ <code>git prune</code>指令也是要給它設定到期日,所以剛才的指令其實原理如下<ul> <li>$ <code>git gc --prune=now</code> = $ <code>git gc</code> + $ <code>git prune --expire=now</code></li> </ul> </li> <li>還有什麼方式會產生出<code>Unreachable狀態</code>的物件?</li> <li>當已經將檔案加入暫存區(staging area)後,卻又將該檔案從Git版控中移除,脫離Git的控管,變為<code>Untracked File</code>狀態</li> <li>因為一旦Git物件產生後,除非手動進 <code>.git/objects/</code> 目錄處理掉,不然該物件就會一直留在那邊了</li> <li>可先參考<a href=#git其實不是在做差異備份而是在為當時的專案建立快照snapshot>Git其實不是在做差異備份,而是在為當時的專案建立快照(snapshot)</a>的 $ <code>git ls-files -s</code> 章節</li> <li>可先參考<a href=#-git-rm---cached-vs-gitignore-比較>$ <code>git rm --cached</code> V.S. <code>.gitignore</code> 比較</a>的 $ <code>git rm --cached</code> 部分</li> <li><code>情境說明</code><ul> <li>$ <code>echo "手動產生一個Unreachable物件" &gt; unreachable.html</code></li> <li>$ <code>git add unreachable.html</code></li> <li>$ <code>git ls-files -s</code></li> <li>把檔案加到暫存區(staging area)後,檢視一下目前的Git物件列表(包含工作目錄 &amp; 暫存區 中的)</li> <li>$ <code>git rm --cached unreachable.html</code></li> <li>將<code>unreachable.html</code>這個檔案從Git控管中移除,脫離Git控管,變為<code>Untracked file</code>狀態</li> <li>$ <code>git fsck --unreachable</code></li> <li>會顯示目前<code>unreachable.html</code>這個檔案成為<code>Unreachable狀態</code>的物件</li> <li><img alt=在Commit之前猶豫不決,會產生出Unreachable狀態的物件 src=../../assets/pics/git/%E5%9C%A8Commit%E4%B9%8B%E5%89%8D%E7%8C%B6%E8%B1%AB%E4%B8%8D%E6%B1%BA%2C%E6%9C%83%E7%94%A2%E7%94%9F%E5%87%BAUnreachable%E7%8B%80%E6%85%8B%E7%9A%84%E7%89%A9%E4%BB%B6.png></li> <li>$ <code>git cat-file -p &lt;該Unreachable狀態的Blob物件的id&gt;</code></li> <li><img alt="用git cat-file -p <該Unreachable狀態的Blob物件的id>  來檢視該Unreachable狀態的物件的內容" src=../../assets/pics/git/%E7%94%A8git%20cat-file%20-p%20%3C%E8%A9%B2Unreachable%E7%8B%80%E6%85%8B%E7%9A%84Blob%E7%89%A9%E4%BB%B6%E7%9A%84id%3E%20%20%E4%BE%86%E6%AA%A2%E8%A6%96%E8%A9%B2Unreachable%E7%8B%80%E6%85%8B%E7%9A%84%E7%89%A9%E4%BB%B6%E7%9A%84%E5%85%A7%E5%AE%B9.png></li> </ul> </li> <li>被刪除的<code>標籤</code>(Tag)物件,也會成為<code>Unreachable狀態</code>的物件<ul> <li>可先參考<a href=#tag-標籤-是什麼><code>Tag</code> (標籤) 是什麼?</a> </li> <li>$ <code>git tag -a unreachable_object -m "刪除Tag物件後,會產生Unreachable狀態的物件"</code></li> <li>建立一個<code>有附註標籤</code>(Annotated Tag),因為<code>標籤</code>(Tag)物件原本是指向某個<code>Commit物件</code>,但當該有附註標籤被刪除時,這個被指向的<code>Commit物件</code>就會變成<code>Unreachable狀態</code>的物件</li> <li>$ <code>git tag -d unreachable_object</code></li> <li>刪除該<code>有附註標籤</code>(Annotated Tag)</li> <li>$ <code>git fsck --unreachable</code></li> <li>會顯示這個被刪除的Tag物件(<code>unreachable_object</code>),該檔案會變成為<code>Unreachable狀態</code>的物件</li> <li>因為它不像<code>Commit物件</code>,還會有<code>Reflog</code>對它念念不忘,已經沒有其他物件或指標指向這個<code>Tag物件</code>,所以這個已被刪除的<code>Tag物件</code>就會立刻變成<code>Unreachable狀態</code></li> </ul> </li> <li>在做<code>Rebase</code>的時候,其實也會產生出多個<code>Unreachable狀態</code>的物件<ul> <li>可先參考<a href=#分支branch操作>分支(branch)操作</a>的$ <code>git rebase</code>原理的部分</li> <li>因為在<code>Rebase</code>的過程中,Git會把原本的<code>Commit物件</code>們分別複製一份到新的<code>base分支</code>上並且重新計算一份新的<code>SHA-1</code>值給這些新的<code>Commit物件</code>; 同時,最後<code>分支</code>與<code>HEAD</code>也都會遷移過去新的<code>Commit物件</code>上,所以這時候原本舊的那些<code>Commit物件</code>們,就會變成<code>Unreachable狀態</code>的物件們</li> </ul> </li> <li>總結: 在Git的世界中<code>Unreachable狀態</code>的物件其實是還蠻常見到的,以下情況都會產生出<code>Unreachable狀態</code>的物件<ul> <li>利用$ <code>git reset --hard</code>切到別的<code>Commit物件</code>上後,並且將<code>Reflog</code>設定為已到期後; 這時候在<code>Reset</code>之前,Git原本指向的那些<code>Commit物件</code>就會變成<code>Unreachable狀態</code></li> <li>新增一個檔案,用$ <code>git add</code>加到暫存區後,又用了$ <code>git rm --cached</code>將該檔案從Git控管中移除,脫離Git控管,變為<code>Untracked file</code>狀態</li> <li>如果在<code>commit</code>之前,檔案$ <code>git add</code>之後又再修改,然後再執行$ <code>git add</code>指令,也會產生出<code>Unreachable狀態</code>的物件</li> <li>即便是$ <code>git commit --amend</code>這種單純修改<code>commit message</code>的指令也會產生出<code>Unreachable狀態</code>的物件</li> <li>被刪除的<code>標籤</code>(Tag)物件,也會成為<code>Unreachable狀態</code>的物件</li> <li>在做<code>Rebase</code>的時候,其實也會產生出多個<code>Unreachable狀態</code>的物件</li> </ul> </li> </ul> <hr> <h3 id=_5>觀念釐清<a class=headerlink href=#_5 title="Permanent link">&para;</a></h3> <blockquote> <p><code>git ls-files</code> - Show information about files in the index and the working tree<br> <code>git verify-pack</code> - Validate packed Git archive files<br> <code>Unreachable Object</code> - 沒有任何物件或指標指著它,如同字面上說的"無法到達的"; 但它仍可以指向其他物件 <code>Dangling Object</code> - 跟<code>Unreachable物件</code>一樣,沒有任何物件或指標指著它,它也沒有指著其他物件,如同完全"懸在天邊"的一顆物件</p> </blockquote> <h4 id=git_10>Git無法控管 <code>空目錄/</code><a class=headerlink href=#git_10 title="Permanent link">&para;</a></h4> <ul> <li>Git在產生物件時,只在乎"檔案內容",所以如果只是新增一個"空的目錄",Git是沒有辦法處理該空目錄的</li> <li>原因: Git會對檔案的"內容"使用<code>SHA-1</code>演算法計算然後再<code>.git/objects/</code>目錄裡,建立對應的目錄及檔案,如果是一個空目錄的話,就沒有"內容"可以計算,所以Git連感應都感應不到,因此<code>空目錄</code>對Git來說連<code>Untracked file</code>都稱不上喔</li> <li>空的目錄也不會被commit</li> <li><img alt=git不會追蹤空目錄 src=../../assets/pics/git/git%E4%B8%8D%E6%9C%83%E8%BF%BD%E8%B9%A4%E7%A9%BA%E7%9B%AE%E9%8C%84.png></li> <li>如果還是想讓空目錄被Git追蹤,只要在空目錄中隨便放一個檔案就行了,慣例上習慣放<code>.keep</code> 或是 <code>.gitkeep</code> 的空檔案,讓Git能"感應"到這個目錄的存在</li> <li><img alt=加入.gitkeep檔案到空目錄讓Git能感應到 src=../../assets/pics/git/%E5%8A%A0%E5%85%A5.gitkeep%E6%AA%94%E6%A1%88%E5%88%B0%E7%A9%BA%E7%9B%AE%E9%8C%84%E8%AE%93Git%E8%83%BD%E6%84%9F%E6%87%89%E5%88%B0.png></li> <li>利用$ <code>git status</code> 就可以看到Git感應到這個目錄(empty_dir)的存在了,其實是感應到裡⾯那個 <code>.gitkeep</code> 檔案的存在</li> </ul> <h4 id=git-rm-cached-vs-gitignore>$ <code>git rm --cached</code> V.S. <code>.gitignore</code> 比較<a class=headerlink href=#git-rm-cached-vs-gitignore title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git rm --cached</code> V.S. <code>.gitignore</code> 比較</li> <li>$ <code>git rm xxx.html --cached</code>:並不會將檔案真的刪除掉,僅把暫存區(staging area)該檔案從Git控管中移除,脫離Git控管,變為<code>Untracked file</code>狀態;若原本在工作目錄(working directory)中的檔案,不管是否有做過修改(modified)都將留下</li> <li>$ <code>.gitignore</code>:是開發者指定好要Git版控"忽略"掉的檔案和規則,設定好後,Git就不會控管這些檔案了</li> </ul> <h4 id=git-git>在專案中的整個<code>.git/</code> 目錄是Git版控的核心檔案<a class=headerlink href=#git-git title="Permanent link">&para;</a></h4> <ul> <li>當檔案被刪除時都還能就回來,因為整個Git紀錄都是放在該專案的根目錄 <code>.git/</code> 目錄裡面,所以如果真的不小心把 <code>.git/</code> 刪掉的話,就表示歷史紀錄也被刪掉了,就真的沒救了...</li> </ul> <h4 id=git-reset-commit>$ <code>git reset</code> 是用來"前往"到指定的<code>Commit物件</code>上的<a class=headerlink href=#git-reset-commit title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git reset</code>的Reset這個英文單字在中文翻譯是"重新設定",但事實上$ <code>git reset</code>指令比較像是"前往"或是"變成",也就是"go to"或是"become"的概念</li> <li>例如: $ <code>git reset HEAD~2</code></li> <li>這個指令應該要解讀成,"我要前往兩個commit之前的狀態" 或是 "我要變成兩個commit之前的狀態",而隨著使用不同的參數模式(<code>mixed or soft or hard</code>),原本的這些檔案就會被丟到不同的區域</li> <li>實際上$ <code>git reset</code>指令也不是真的刪除或是重新設定commit,只是"前往"到指定的commit物件中,那些看起來好像不見的東西只是暫時看不到,但其實隨時都可以再撿回來</li> </ul> <h4 id=gitblobtreecommittag>Git四大物件(<code>Blob</code>,<code>Tree</code>,<code>Commit</code>,<code>Tag</code>)彼此之間其實是平行關係<a class=headerlink href=#gitblobtreecommittag title="Permanent link">&para;</a></h4> <ul> <li>Git的四大物件(<code>Blob</code>,<code>Tree</code>,<code>Commit</code>,<code>Tag</code>)彼此之間是"沒有"階層或是目錄,子目錄的關係,大家都是平行的關係,此關係鏈稱為DAG(Directed Acyclic Graph),中文上稱為"有向無循環圖"</li> </ul> <h4 id=gitsnapshot>Git其實不是在做差異備份,而是在為當時的專案建立快照(snapshot)<a class=headerlink href=#gitsnapshot title="Permanent link">&para;</a></h4> <ul> <li>Git 不是在做差異備份,而是<code>為當時的專案資料建立快照(Snapshot)</code>,如果專案內沒有變更的檔案就不會多儲存一份來佔用磁碟空間,而只是增加了一筆這個檔案的對應連結,開發者開啟新版本存取這個檔案時,還是開啟先前的舊版檔案,而不是開啟內容相同的新副本</li> <li>因此,只要該檔案的內容改了一個字,因為計算出來的<code>SHA-1值</code>不同,Git就會為它做出一顆全新的<code>Blob物件</code>,而"不是只記錄差異"</li> <li>Git在製作新的<code>Blob物件</code>時會先進行壓縮,但為了因應"其實只修改了一點點就要整個檔案重新備份一遍"的作法而有點浪費硬碟的儲存空間,<code>Git有一套自己的資源回收機制</code></li> <li>Git的<code>資源回收機制</code>,當這個機制"觸發"的時候( 通常會在Git覺得該專案的物件(objects)太多時 ),Git會以非常有效率的方式壓縮物件以及製作索引 <ul> <li><code>情境說明</code>:</li> <li>$ <code>git ls-files -s</code>: 檢視暫存區(staging area)和工作目錄(working directory)中的檔案情況</li> <li><code>-s</code> (=&gt; <code>--stage</code>): 顯示暫存區(staging area)的檔案資訊</li> <li><img alt="git ls-files 顯示暫存區或是工作目錄中的檔案資訊" src=../../assets/pics/git/git%20ls-files%20%E9%A1%AF%E7%A4%BA%E6%9A%AB%E5%AD%98%E5%8D%80%E6%88%96%E6%98%AF%E5%B7%A5%E4%BD%9C%E7%9B%AE%E9%8C%84%E4%B8%AD%E7%9A%84%E6%AA%94%E6%A1%88%E8%B3%87%E8%A8%8A.png></li> <li>$ <code>git gc</code>: 清除非必要(unnecessary)的檔案和優化本地端儲存庫(local repository)的空間 </li> <li><img alt="git gc資源回收機制的圖解說明" src=../../assets/pics/git/git%20gc%E8%B3%87%E6%BA%90%E5%9B%9E%E6%94%B6%E6%A9%9F%E5%88%B6%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>這個指令會把原本放在 <code>.git/objects/</code> 目錄下的那些物件全部打包到 <code>.git/objects/pack/</code> 目錄下</li> <li><img alt="git gc後打包的物件會儲存在 .git/objects/pack" src=../../assets/pics/git/git%20gc%E5%BE%8C%E6%89%93%E5%8C%85%E7%9A%84%E7%89%A9%E4%BB%B6%E6%9C%83%E5%84%B2%E5%AD%98%E5%9C%A8%20.git%3Aobjects%3Apack.png></li> <li>$ <code>git verify-pack -v</code> &lt;<code>.git/objects/pack/pack-xxxxxx.idx</code>&gt;: 確認Git打包(packed)好的檔案情況</li> <li><code>-v</code>(=&gt; <code>--verbose</code>): 顯示打包過後的檔案詳細資訊 </li> <li>第一欄: <code>SHA-1值</code></li> <li>第二欄: <code>物件的型態</code></li> <li>第三欄: <code>檔案大小</code></li> </ul> </li> <li>統整: Git什麼時候會自動觸發<code>資源回收機制</code>呢?<ul> <li>當在 <code>.git/objects/</code> 目錄下的物件或是打包過的packfile數量過多的時候,Git會<code>自動觸發資源回收指令</code></li> <li>當執行 $ <code>git push</code> 指令把內容推至遠端伺服器時</li> </ul> </li> </ul> <h4 id=catdogdogcat>把<code>cat分支</code>合併到<code>dog分支</code>&amp;把<code>dog分支</code>合併到<code>cat分支</code>有什麼不同呢?<a class=headerlink href=#catdogdogcat title="Permanent link">&para;</a></h4> <ul> <li>在Git中,合併分支是<code>哪個分支</code>合併掉<code>哪個分支</code>其實沒有太大差異</li> <li><code>情境說明</code><ul> <li><img alt=A合併B分支＆B合併A分支的圖解說明 src=../../assets/pics/git/A%E5%90%88%E4%BD%B5B%E5%88%86%E6%94%AF%EF%BC%86B%E5%90%88%E4%BD%B5A%E5%88%86%E6%94%AF%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/ >https://gitbook.tw/</a></li> <li>當<code>cat分支</code>和<code>dog分支</code>都是來自<code>master分支</code>時</li> <li>假設這次是<code>cat分支</code>要合併掉<code>dog分支</code>,為了要進行這次的合併,Git會做出一個新的<code>Commit物件</code>,而這個新的<code>Commit物件</code>會分別指向<code>cat分支</code>和<code>dog分支</code>,而<code>HEAD</code>會繼續隨著<code>cat分支</code>往前,而<code>dog分支</code>會留在原地</li> <li><img alt=當A合併掉B分支後的圖解說明 src=../../assets/pics/git/%E7%95%B6A%E5%90%88%E4%BD%B5%E6%8E%89B%E5%88%86%E6%94%AF%E5%BE%8C%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/ >https://gitbook.tw/</a></li> </ul> </li> <li>結論: 其實以"結果"來看,誰合併誰其實沒差,因為合併後產生的新的<code>Commit物件</code>的內容都包含了兩個原來的分支(<code>cat</code> &amp; <code>dog</code>)<ul> <li>細節提醒: 這兩個分支都是平等關係,細微的差異是<code>cat</code>合併掉<code>dog</code>分支的話,<code>cat分支</code>會往前移動</li> <li>細節提醒: 合併分支後而產生的新的<code>Commit物件</code>其實裡面會紀錄誰是誰的老爸,當<code>cat</code>合併<code>dog分支</code>的話,<code>cat分支</code>就會寫在前面</li> <li>可以用$ <code>git cat-file -p &lt;物件id&gt;</code> 來檢視該<code>Commit物件</code>的<code>Parent</code>(通常會指向前一次的<code>Commit物件</code>)是指向哪個<code>Commit物件</code></li> <li>可參考<a href=#git四大物件blobtreecommittag彼此之間其實是平行關係>Git 的四大物件(<code>Blob</code>,<code>Tree</code>,<code>Commit</code>,<code>Tag</code>)觀念介紹</a></li> <li><img alt="git cat-file -p <Commit物件>可以用來檢視該Commit物件的Parent是誰_統整" src=../../assets/pics/git/git%20cat-file%20-p%20%3CCommit%E7%89%A9%E4%BB%B6%3E%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BE%86%E6%AA%A2%E8%A6%96%E8%A9%B2Commit%E7%89%A9%E4%BB%B6%E7%9A%84Parent%E6%98%AF%E8%AA%B0_%E7%B5%B1%E6%95%B4.gif></li> </ul> </li> </ul> <h4 id=_6>合併分支其實不是真的在合併分支!<a class=headerlink href=#_6 title="Permanent link">&para;</a></h4> <ul> <li>所謂的"合併分支"其實是在合併兩個分支分別指向的兩個<code>Commit物件</code></li> <li>畢竟分支只是一張貼紙而已,它是沒辦法被"合併"的,我們通常用"合併分支"這個說法只是比較好想像和溝通而已</li> <li><img alt=其實合併分支是在合併兩個分支分別指向的兩個Commit物件的圖解說明-統整 src=../../assets/pics/git/%E5%85%B6%E5%AF%A6%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E6%98%AF%E5%9C%A8%E5%90%88%E4%BD%B5%E5%85%A9%E5%80%8B%E5%88%86%E6%94%AF%E5%88%86%E5%88%A5%E6%8C%87%E5%90%91%E7%9A%84%E5%85%A9%E5%80%8BCommit%E7%89%A9%E4%BB%B6%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E-%E7%B5%B1%E6%95%B4.gif><br> 參考圖片出處<a href=https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging>https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging</a></li> </ul> <h4 id=resetrebaserevert><code>Reset</code>、<code>Rebase</code>、<code>Revert</code> 三個指令有什麼差別?<a class=headerlink href=#resetrebaserevert title="Permanent link">&para;</a></h4> <table> <thead> <tr> <th align=center>指令</th> <th align=center>改變歷史紀錄</th> <th align=center>說明</th> <th align=center>適合使用情境</th> </tr> </thead> <tbody> <tr> <td align=center>Reset</td> <td align=center>是</td> <td align=center>把目前的狀態設定成某個指定的 Commit 的狀態</td> <td align=center>通常適用於尚未推出去的 Commit</td> </tr> <tr> <td align=center>Rebase</td> <td align=center>是</td> <td align=center>不管是新增、修改、刪除 Commit 都相當方便，用來整理、編輯還沒有推出去的 Commit 相當方便</td> <td align=center>通常也只適用於尚未推出去的 Commit</td> </tr> <tr> <td align=center>Revert</td> <td align=center>否</td> <td align=center>新增一個 Commit 來反轉（或說取消）另一個 Commit 的內容，原本的 Commit 依舊還是會保留在歷史紀錄中。雖然會因此而增加 Commit 數</td> <td align=center>但通常比較適用於已經推出去的 Commit，或是不允許使用 Reset 或 Rebase 之修改歷史紀錄的指令的場合</td> </tr> </tbody> </table> <ul> <li>參考表格出處: <a href=https://gitbook.tw/chapters/rewrite-history/reset-revert-and-rebase.html>https://gitbook.tw/chapters/rewrite-history/reset-revert-and-rebase.html</a></li> </ul> <h4 id=tagbranch><code>標籤(Tag)</code>跟<code>分支(branch)</code>有什麼不同呢?<a class=headerlink href=#tagbranch title="Permanent link">&para;</a></h4> <ul> <li><code>標籤(Tag)</code>與<code>分支(branch)</code>都是一種指標,都會放在 .git/refs/ 目錄裡面,但放的位置不同</li> <li><code>標籤(Tag)</code> 會放在 <code>.git/refs/tags/</code> 目錄裡面</li> <li><code>分支(branch)</code>會放在 <code>.git/refs/heads/</code> 目錄裡面</li> <li>可先參考<a href=#tag-標籤-是什麼><code>Tag</code> (標籤) 是什麼?</a></li> <li>可先參考<a href=#分支branch是什麼><code>分支(branch)</code>是什麼?</a></li> <li><code>標籤(Tag)</code>與<code>分支(branch)</code>的內容看起來會很像,都是<code>40</code>個字元的<code>SHA-1值</code></li> <li><code>輕量標籤</code>(lightweight tag)指向的是一個Commit物件<ul> <li>$ <code>cat .git/refs/tags/&lt;輕量標籤的名稱&gt;</code></li> <li><img alt="檢視cat .git/refs/tags/<輕量標籤的名稱> 的內容" src=../../assets/pics/git/%E6%AA%A2%E8%A6%96cat%20.git%3Arefs%3Atags%3A%3C%E8%BC%95%E9%87%8F%E6%A8%99%E7%B1%A4%E7%9A%84%E5%90%8D%E7%A8%B1%3E%20%E7%9A%84%E5%85%A7%E5%AE%B9.png></li> </ul> </li> <li><code>有附註標籤</code>(annotated tag)指向的是一個<code>Tag物件</code>,而這個<code>Tag物件</code>才會指向一個<code>Commit物件</code><ul> <li>$ <code>cat .git/refs/tags/&lt;有附註標籤的名稱&gt;</code></li> <li><img alt="檢視cat .git/refs/tags/<有附註標籤的名稱> 的內容" src=../../assets/pics/git/%E6%AA%A2%E8%A6%96cat%20.git%3Arefs%3Atags%3A%3C%E6%9C%89%E9%99%84%E8%A8%BB%E6%A8%99%E7%B1%A4%E7%9A%84%E5%90%8D%E7%A8%B1%3E%20%E7%9A%84%E5%85%A7%E5%AE%B9.png></li> </ul> </li> <li>重要: <code>標籤(Tag)</code>與<code>分支(branch)</code>最大的差別在於</li> <li><code>分支(branch)</code> "會隨著" <code>commit紀錄</code>移動,也就是說當Git往前推進一個<code>commit紀錄</code>時,它所在的分支會跟著往前移動</li> <li><code>標籤(Tag)</code> 不會隨著 <code>commit紀錄</code>移動,也就是說標籤一旦貼上去後,不管<code>commit紀錄</code>怎麼前進,標籤還是會停留在原來貼的那個位置上</li> <li>結論: 某方面來說,我們可以把<code>分支(branch)</code>視為會移動的<code>標籤(Tag)</code></li> </ul> <h4 id=unreachable-dangling><code>Unreachable物件</code> &amp; <code>Dangling物件</code> 有什麼不同呢?<a class=headerlink href=#unreachable-dangling title="Permanent link">&para;</a></h4> <ul> <li><code>Unreachable Object</code> : 沒有任何物件或指標指著它,如同字面上說的"無法到達的"; 但它仍可以指向其他物件</li> <li><code>Dangling Object</code> : 跟<code>Unreachable物件</code>一樣,沒有任何物件或指標指著它,它也沒有指著其他物件,如同完全"懸在天邊"的一顆物件</li> <li><code>Dangling物件</code>可以算是<code>Unreachable物件</code>的子集合,它也是一種<code>Unreachable物件</code>,所以在進行$ <code>git gc</code>時,也會一起被回收走</li> <li>什麼情況下Git會產生出<code>Dangling物件</code>呢?</li> <li><code>情境說明</code></li> <li>$ <code>echo "test for dangling object" &gt; dangling_object.html</code></li> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "新增dangling object 內容"</code></li> <li>上述三步驟再重複做一遍,已新增出測試要用的2次commit紀錄</li> <li>$ <code>git reset HEAD~2 --hard</code>: 切回到<code>HEAD指標</code>指向的前2次<code>Commit物件</code></li> <li>$ <code>git fsck --unreachable --no-reflogs</code>: 顯示所有<code>Unreachable狀態</code>的物件和 <code>Dangling狀態</code>的物件<ul> <li><img alt=Dangling物件的統整筆記 src=../../assets/pics/git/Dangling%E7%89%A9%E4%BB%B6%E7%9A%84%E7%B5%B1%E6%95%B4%E7%AD%86%E8%A8%98.gif> </li> </ul> </li> <li>注意! 此時的<code>3d3bce0</code>,<code>4cfc041</code>這兩個<code>Commit物件</code>都已經變成<code>Unreachable狀態</code>的物件; </li> <li>$ git fsck --no-reflogs: 只顯示出<code>Dangling狀態</code>的物件<ul> <li><img alt="利用git reflog檢視透過手動建立Dangling物件後,HEAD指標的變化紀錄" src=../../assets/pics/git/%E5%88%A9%E7%94%A8git%20reflog%E6%AA%A2%E8%A6%96%E9%80%8F%E9%81%8E%E6%89%8B%E5%8B%95%E5%BB%BA%E7%AB%8BDangling%E7%89%A9%E4%BB%B6%E5%BE%8C%2CHEAD%E6%8C%87%E6%A8%99%E7%9A%84%E8%AE%8A%E5%8C%96%E7%B4%80%E9%8C%84.png></li> </ul> </li> </ul> <h4 id=git-log-git-reflog>$ <code>git log</code> &amp; <code>git reflog</code> 有什麼不同呢?<a class=headerlink href=#git-log-git-reflog title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git log</code>: 可以顯示所有<code>提交</code>(commit)過的版本資訊<blockquote> <p>$ git log - Show commit logs --- by 官方文件<br></p> </blockquote> </li> <li><img alt="git log的畫面" src=../../assets/pics/git/git%20log%E7%9A%84%E7%95%AB%E9%9D%A2.png></li> <li>$ <code>git reflog</code>: 可以檢視所有分支的所有操作記錄(包括<code>已經被刪除的commit記錄</code>和<code>Reset操作</code>)<blockquote> <p>$ <code>git reflog</code> - Manage reflog information --- by 官方文件<br></p> </blockquote> </li> <li><img alt="git reflog的畫面" src=../../assets/pics/git/git%20reflog%E7%9A%84%E7%95%AB%E9%9D%A2.png></li> </ul> <hr> <h3 id=_7>實戰情境題<a class=headerlink href=#_7 title="Permanent link">&para;</a></h3> <blockquote> <p><code>git stash</code> - Stash the changes in a dirty working directory away<br> <code>git filter-branch</code> - Rewrite branches<br> <code>git cherry-pick - Apply the changes introduced by some existing commits</code><br> <code>git fsck</code> - Verifies the connectivity and validity of the objects in the database<br></p> </blockquote> <h4 id=git-add>如果在git add之後又修改了那個檔案的內容呢?<a class=headerlink href=#git-add title="Permanent link">&para;</a></h4> <ul> <li>新增了一個檔案叫做abc.txt</li> <li>執行 $ <code>git add abc.txt</code> 把檔案加到暫存區</li> <li>又再編輯了一次該檔案</li> <li>正確做法:必須再將該檔案 $ <code>git add abc.txt</code> 到暫存區一遍</li> <li><img alt="git add後又編輯檔案圖解說明" src=../../assets/pics/git/git%20add%E5%BE%8C%E5%8F%88%E7%B7%A8%E8%BC%AF%E6%AA%94%E6%A1%88%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> <h4 id=git-reset-hard>如果不小心使用$ <code>git reset --hard</code> 模式,能救回來嗎?<a class=headerlink href=#git-reset-hard title="Permanent link">&para;</a></h4> <ul> <li>假如不小心$ <code>git reset HEAD~2 --hard</code>,</li> <li>$ <code>git reflog</code> 是當HEAD有移動的時候(例如切換分支or $ <code>git reset</code> 時,Git都會在 <code>Reflog</code> 上面做記錄),在 <code>Reflog</code> 中,越新的紀錄寫在越上面<ul> <li> <blockquote> <p>官方定義: Reference logs, or "reflogs", record when the tips of branches and other references were updated in the local repository. </p> </blockquote> </li> </ul> </li> <li>可以利用$ <code>git reflog</code> 來檢視<code>HEAD</code>的變化紀錄<ul> <li>當切換分支時,HEAD會變動</li> <li>當$ <code>git reset</code> 時,HEAD會變動</li> </ul> </li> <li>解決方法:直接回到正確(=&gt;reset錯誤前的那一次)的commit物件上<ul> <li>$ <code>git reset c015c1f --hard</code></li> <li>就可以把剛剛的東西救回來了</li> <li><img alt="git reset --hard後透過git reflog+git reset來挽救的圖解說明" src=../../assets/pics/git/git%20reset%20--hard%E5%BE%8C%E9%80%8F%E9%81%8Egit%20reflog%2Bgit%20reset%E4%BE%86%E6%8C%BD%E6%95%91%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.gif></li> <li>補充: $ <code>git reflog</code> = $ <code>git log -g</code> = $ <code>git log --walk-reflogs</code></li> </ul> </li> </ul> <h4 id=commit_4>如果這次只想commit一個檔案中的部份內容的話,該怎麼做呢?<a class=headerlink href=#commit_4 title="Permanent link">&para;</a></h4> <ul> <li><code>git add -p xxx.hmtl</code>: 在$ <code>git add</code>將檔案加入暫存區(staging area)的時候,加上 <code>-p</code> 參數,透過互動式介面,選擇要$ <code>git add</code>的範圍<ul> <li><code>-p</code> (=&gt; <code>--patch</code>): 可以互動式地選擇該檔案的哪些部分要加入暫存區(staging area),哪些不用(留在工作目錄就好)</li> <li><code>e</code> (=&gt; edit): 編輯該檔案中的哪些部分要新增到暫存區(staging area)</li> <li><img alt="git add -p選擇要新增到暫存區的範圍" src=../../assets/pics/git/git%20add%20-p%E9%81%B8%E6%93%87%E8%A6%81%E6%96%B0%E5%A2%9E%E5%88%B0%E6%9A%AB%E5%AD%98%E5%8D%80%E7%9A%84%E7%AF%84%E5%9C%8D.gif></li> </ul> </li> </ul> <h4 id=branch_2>如果修改專案的某些檔案到一半,卻不小心先切換到別的分支(branch),該怎麼辦?<a class=headerlink href=#branch_2 title="Permanent link">&para;</a></h4> <ul> <li>$ <code>git checkout -b tiger</code>: 先切換到tiger分支</li> <li>$ <code>echo tiger 123 &gt; tiger_test.html</code>: 新增一個檔案<code>tiger_test.html</code>,並在裡面輸入一串文字</li> <li>也編輯<code>pizza.html</code>,新增一行文字</li> <li>此時,切換到<code>master</code>分支,會發現剛剛新增的檔案(<code>tiger_test.html</code>)以及修改的檔案(<code>pizza.html</code>)都還是會留在工作目錄(working directory)不受影響</li> <li><img alt="檔案修改到一半卻git checkout分支的圖解說明-part_總結" src=../../assets/pics/git/%E6%AA%94%E6%A1%88%E4%BF%AE%E6%94%B9%E5%88%B0%E4%B8%80%E5%8D%8A%E5%8D%BBgit%20checkout%E5%88%86%E6%94%AF%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E-part_%E7%B8%BD%E7%B5%90.gif></li> <li>總結: Git切換分支( <code>$ git checkout &lt;branch name&gt;</code> )時,並不會影響到已經在工作目錄(working directory)的那些修改喔!</li> </ul> <h4 id=_8>如果不小心把還沒合併的分支刪掉了,該怎麼挽救?<a class=headerlink href=#_8 title="Permanent link">&para;</a></h4> <ul> <li>可先參考 <a href=#分支branch是什麼><code>分支(branch)</code>是什麼?</a> 的刪除分支篇</li> <li>$ <code>git branch -D &lt;尚未合併的分支名稱&gt;</code>: 強制刪除該分支( 不管該分支是否已經合併(merged)到其上游分支(upstream branch) )<ul> <li>此時會顯示"被刪除的分支"當下是指向哪個<code>Commit物件</code>,可以先記下來這個<code>Commit物件</code>的id</li> <li><img alt=不小心刪掉尚未合併的分支的圖解說明 src=../../assets/pics/git/%E4%B8%8D%E5%B0%8F%E5%BF%83%E5%88%AA%E6%8E%89%E5%B0%9A%E6%9C%AA%E5%90%88%E4%BD%B5%E7%9A%84%E5%88%86%E6%94%AF%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>補充:<code>分支(branch)</code>只是一個指向某個<code>Commit物件</code>的貼紙,刪除這個貼紙"並不會"造成那些<code>Commit物件</code>消失</li> <li>所以既然刪掉分支後,那些<code>Commit物件</code>都還在的話,只是因為我們當下通常沒有記下那些<code>Commit物件的id</code>,所以比較不容易再拿回來使用,這時我們可以創造一個<code>新的分支(new branch)</code>來把這些<code>Commit物件</code>都接回來!</li> <li>$ <code>git branch &lt;新的分支名稱&gt; &lt;剛剛被刪掉的分支當下指向的Commit物件的id&gt;</code>: 建立一個<code>新的分支(new branch)</code>並讓該分支指向這個<code>Commit物件</code>,相當於再拿一張新的貼紙貼回去的意思</li> <li>補充: 若當下刪除"尚未合併分支"的時候,沒有記下該分支當下指向的<code>Commit物件</code>的id,可以用git reflog來找找看,因為Git的Reflog會預設保留<code>30</code>天</li> <li>可參考 <a href=#如果不小心使用-git-reset---hard-模式能救回來嗎>如果不小心使用$ <code>git reset --hard</code> 模式,能救回來嗎?</a></li> </ul> </li> </ul> <h4 id=commitbranch>如果想從過去的某次<code>commit紀錄</code>再長一個<code>新的分支(branch)</code>出來,該如何做呢?<a class=headerlink href=#commitbranch title="Permanent link">&para;</a></h4> <ul> <li>第一步驟: 必須先回到過去的那個<code>commit紀錄</code>的狀態<ul> <li>$ <code>git checkout &lt;要回到的過去的那個Commit物件的id&gt;</code> </li> </ul> </li> <li>第二步驟: 新增一個<code>分支(branch)</code>在過去的那個<code>Commit物件</code>上<ul> <li>$ <code>git checkout -b &lt;新的分支名稱&gt;</code> </li> </ul> </li> <li>補充: 在執行第一步驟時<ul> <li>這時候可能會發生 <code>detached HEAD</code> 狀態 (是因為過去的那個<code>Commit物件</code>目前沒有分支指向它)</li> <li>這時候可以再切換到過去的那個<code>commit紀錄</code>時,同時新增一個<code>分支(branch)</code>,以防跳出 <code>detached HEAD</code> 狀態</li> </ul> </li> <li>也可以直接一行指令完成,以下兩種方式都是在表達"請Git幫我在<code>&lt;要回到的過去的那個Commit物件&gt;</code>上貼上一張ocean的<code>分支(branch)</code>貼紙"<ul> <li>$ <code>git branch &lt;新的分支名稱&gt; &lt;要回到的過去的那個Commit物件的id&gt;</code></li> <li>例如: $ <code>git branch ocean</code> </li> <li>也可以更方便地,在回到過去的commit紀錄時,新增一個分支,並同時切換到那個分支</li> <li>$ <code>git checkout -b &lt;新的分支名稱&gt; &lt;要回到的過去的那個Commit物件的id&gt;</code></li> <li><img alt=回到過去的某個commit紀錄並新增分支_統整 src=../../assets/pics/git/%E5%9B%9E%E5%88%B0%E9%81%8E%E5%8E%BB%E7%9A%84%E6%9F%90%E5%80%8Bcommit%E7%B4%80%E9%8C%84%E4%B8%A6%E6%96%B0%E5%A2%9E%E5%88%86%E6%94%AF_%E7%B5%B1%E6%95%B4.gif> </li> </ul> </li> </ul> <h4 id=both-modified>當兩個分支都編輯了同一個檔案(<code>both modified 狀態</code>),造成<code>合併分支時發生衝突</code>了,該怎麼解決呢?<a class=headerlink href=#both-modified title="Permanent link">&para;</a></h4> <ul> <li>假設有兩個分支都編輯過同一個檔案,若檔案內容不一致,會造成<code>both modified 狀態</code>,造成合併分支時會發生衝突</li> <li><code>情境說明1</code><ul> <li>用<code>Merge方式</code>合併分支時發生衝突</li> <li>建立一個<code>merge_conflict.html</code>的測試<code>合併分支衝突</code>的檔案</li> <li>從<code>master</code>,建立一個<code>sun分支</code>(branch)</li> <li>從<code>master</code>,建立一個<code>moon分支</code>(branch)</li> <li>此時先切換到<code>sun分支</code>,並新增"我是sun分支"到<code>merge_conflict.html</code>的測試<code>合併分支衝突</code>的檔案,加到暫存區後,再commit到本地端repo</li> <li>$ <code>git checkout sun</code></li> <li>新增"我是sun分支"到<code>merge_conflict.html</code>的測試<code>合併分支衝突</code>的檔案</li> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "sun分支編輯merge_conflict.html"</code></li> <li><img alt=合併分支衝突圖解_sun分支 src=../../assets/pics/git/%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81%E5%9C%96%E8%A7%A3_sun%E5%88%86%E6%94%AF.png></li> <li>再切換到<code>moon分支</code>,並新增"我是moon分支"到<code>merge_conflict.html</code>的測試<code>合併分支衝突</code>的檔案,加到暫存區後,再commit到本地端repo</li> <li>$ <code>git checkout moon</code></li> <li>新增"我是moon分支"到<code>merge_conflict.html</code>的測試<code>合併分支衝突</code>的檔案</li> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "moon分支編輯merge_conflict.html"</code></li> <li><img alt=合併分支衝突圖解_moon分支 src=../../assets/pics/git/%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81%E5%9C%96%E8%A7%A3_moon%E5%88%86%E6%94%AF.png></li> <li>$ <code>git merge sun</code>: 將<code>moon分支</code>合併到<code>sun分支</code>的上面</li> <li>此時Git有能力幫忙檢查簡單的衝突</li> <li>可以決定要接受哪個分支的修改,也可以都接受雙方的修改</li> <li><img alt="git merge遇到both modified狀態_圖解說明" src=../../assets/pics/git/git%20merge%E9%81%87%E5%88%B0both%20modified%E7%8B%80%E6%85%8B_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png>`</li> <li>最後用Sourcetree來檢視一下最後的<code>History</code></li> <li>"!" : 代表"有衝突"的檔案</li> <li><img alt=Sourcetree檢視sun和moon分支同時編輯同一個檔案會造成合併分支衝突的圖解說明 src=../../assets/pics/git/Sourcetree%E6%AA%A2%E8%A6%96sun%E5%92%8Cmoon%E5%88%86%E6%94%AF%E5%90%8C%E6%99%82%E7%B7%A8%E8%BC%AF%E5%90%8C%E4%B8%80%E5%80%8B%E6%AA%94%E6%A1%88%E6%9C%83%E9%80%A0%E6%88%90%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> <li>統整圖解說明</li> <li><img alt="合併分支衝突(both modified 狀態)該如何解決_統整" src=../../assets/pics/git/%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81%28both%20modified%20%E7%8B%80%E6%85%8B%29%E8%A9%B2%E5%A6%82%E4%BD%95%E8%A7%A3%E6%B1%BA_%E7%B5%B1%E6%95%B4.gif></li> </ul> </li> <li><code>情境說明2</code><ul> <li>用<code>Rebase方式</code>合併分支時發生衝突</li> <li><img alt="用git rebase來合併分支卻發生衝突時的console錯誤畫面" src=../../assets/pics/git/%E7%94%A8git%20rebase%E4%BE%86%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E5%8D%BB%E7%99%BC%E7%94%9F%E8%A1%9D%E7%AA%81%E6%99%82%E7%9A%84console%E9%8C%AF%E8%AA%A4%E7%95%AB%E9%9D%A2.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/branch/fix-conflict.html>https://gitbook.tw/chapters/branch/fix-conflict.html</a></li> <li>此時<code>HEAD</code>並"沒有指向"任何一個分支,它現在有點像是在修改歷史的時候,卡在某個時空縫隙裡的狀態</li> <li><img alt=Sourcetree檢視目前Rebase方式來合併分支卻發生衝突時,HEAD當下不會指向任何一個分支的圖解說明 src=../../assets/pics/git/Sourcetree%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8DRebase%E6%96%B9%E5%BC%8F%E4%BE%86%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E5%8D%BB%E7%99%BC%E7%94%9F%E8%A1%9D%E7%AA%81%E6%99%82%2CHEAD%E7%95%B6%E4%B8%8B%E4%B8%8D%E6%9C%83%E6%8C%87%E5%90%91%E4%BB%BB%E4%BD%95%E4%B8%80%E5%80%8B%E5%88%86%E6%94%AF%E7%9A%84%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/branch/fix-conflict.html>https://gitbook.tw/chapters/branch/fix-conflict.html</a></li> <li>檢視一下目前Git的狀態</li> <li>$ <code>git status</code></li> <li><img alt="當用Rebase方式來合併分支卻發生衝突時,可以先用git status來檢視目前的狀態" src=../../assets/pics/git/%E7%95%B6%E7%94%A8Rebase%E6%96%B9%E5%BC%8F%E4%BE%86%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E5%8D%BB%E7%99%BC%E7%94%9F%E8%A1%9D%E7%AA%81%E6%99%82%2C%E5%8F%AF%E4%BB%A5%E5%85%88%E7%94%A8git%20status%E4%BE%86%E6%AA%A2%E8%A6%96%E7%9B%AE%E5%89%8D%E7%9A%84%E7%8B%80%E6%85%8B.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/branch/fix-conflict.html>https://gitbook.tw/chapters/branch/fix-conflict.html</a></li> <li>這時候的Git狀態清楚地顯示"rebase in progress"(=&gt; 正在進行中的)</li> <li>同時,兩個分支同時都編輯到的那個檔案會被標示成<code>both modified 狀態</code></li> <li>此時可以直接按照平常的流程,"先將該衝突檔案修正完成後"</li> <li>再將"已修正的檔案" 加到 "暫存區"(staging area)<ul> <li>$ <code>git add &lt;已修正的檔案&gt;</code></li> </ul> </li> <li>最後,接著繼續完成剛剛中斷的Rebase合併分支的操作<ul> <li>$ <code>git rebase --continue</code></li> <li><code>--continue</code>: 當已經修改完衝突檔案後,繼續 "重新啟動" Rebase機制</li> </ul> </li> </ul> </li> <li><code>情境說明3</code><ul> <li>用<code>Merge方式</code>合併分支時發生衝突(=&gt; "當兩個分支都有一個同名稱的圖片檔案時的情況")</li> <li>雖然Git有能力幫忙檢查簡單的衝突並標示出"衝突點"在該檔案哪幾行; 但是如果是圖片檔之類的二進位檔的話,就必須用別的方式來解決了</li> <li>建立一個<code>cutest_animal.jpg</code>的測試<code>合併分支衝突</code>的同名圖片檔案</li> <li>從<code>master</code>,建立一個<code>cat分支</code>(branch)</li> <li>從<code>master</code>,建立一個<code>dog分支</code>(branch)</li> <li>先切換到<code>cat分支</code>並新增一個"同名稱的圖片檔案"(<code>cutest_animal.jpg</code>)</li> <li><img alt=新增一個cat分支,且新增一個cutest_animal的圖片檔案(內容為貓) src=../../assets/pics/git/%E6%96%B0%E5%A2%9E%E4%B8%80%E5%80%8Bcat%E5%88%86%E6%94%AF%2C%E4%B8%94%E6%96%B0%E5%A2%9E%E4%B8%80%E5%80%8Bcutest_animal%E7%9A%84%E5%9C%96%E7%89%87%E6%AA%94%E6%A1%88%28%E5%85%A7%E5%AE%B9%E7%82%BA%E8%B2%93%29.png> </li> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "cat分支 新增cutest_animal.jpg"</code></li> <li>再切換到<code>dog分支</code>並新增一個"同名稱的圖片檔案"(<code>cutest_animal.jpg</code>)</li> <li><img alt=新增一個dog分支,且新增一個cutest_animal的圖片檔案(內容為狗) src=../../assets/pics/git/%E6%96%B0%E5%A2%9E%E4%B8%80%E5%80%8Bdog%E5%88%86%E6%94%AF%2C%E4%B8%94%E6%96%B0%E5%A2%9E%E4%B8%80%E5%80%8Bcutest_animal%E7%9A%84%E5%9C%96%E7%89%87%E6%AA%94%E6%A1%88%28%E5%85%A7%E5%AE%B9%E7%82%BA%E7%8B%97%29.png><br> 參考圖片出處<a href="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQ3Xm4P7nHI3rcMuRdM3KR3av1PqeqaPHW-nA&usqp=CAU">https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcQ3Xm4P7nHI3rcMuRdM3KR3av1PqeqaPHW-nA&amp;usqp=CAU</a></li> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "dog分支 新增cutest_animal.jpg"</code></li> <li>此時切換到<code>cat分支</code>,利用指令合併到<code>dog分支</code>上面</li> <li>$ <code>git merge dog</code><ul> <li>這時會發生合併分支的衝突,並且顯示Git無法自動解決該衝突(<code>Merge conflict in /pics/gitcutest_animal.jpg</code> &amp; <code>Automatic merge failed</code>)`</li> <li><img alt=當兩個分支都有同一個檔名的圖片檔案時,這時候用Merge方式合併時會發生衝突 src=../../assets/pics/git/%E7%95%B6%E5%85%A9%E5%80%8B%E5%88%86%E6%94%AF%E9%83%BD%E6%9C%89%E5%90%8C%E4%B8%80%E5%80%8B%E6%AA%94%E5%90%8D%E7%9A%84%E5%9C%96%E7%89%87%E6%AA%94%E6%A1%88%E6%99%82%2C%E9%80%99%E6%99%82%E5%80%99%E7%94%A8Merge%E6%96%B9%E5%BC%8F%E5%90%88%E4%BD%B5%E6%99%82%E6%9C%83%E7%99%BC%E7%94%9F%E8%A1%9D%E7%AA%81.png></li> </ul> </li> <li>這時候可以決定要採用哪個分支的同名稱圖片檔案(<code>cutest_animal.jpg</code>)<ul> <li>$ <code>git checkout --ours/--theirs &lt;路徑/決定要用的同名稱圖片檔案的檔名&gt;</code></li> <li>假如決定要用"目前所在分支的"圖片檔案</li> <li>$ <code>git checkout --ours cutest_animal.jpg</code></li> <li><code>--ours</code>: 決定要用"目前所在分支的"圖片檔案</li> <li>假如`決定要用"另一個分支的"圖片檔案</li> <li>$ <code>git checkout --theirs cutest_animal.jpg</code></li> <li><code>--theirs</code>: 決定要用"另一個分支的"圖片檔案</li> </ul> </li> <li>接著記得繼續按照平常的流程,將"已修正的檔案" 加到 "暫存區"(staging area)</li> <li>$ <code>git add &lt;路徑/決定要用的同名稱圖片檔案的檔名&gt;</code></li> <li>$ <code>git commit -m "git merge圖片檔案發生衝突時,可以用git checkout --ours/--theirs參數 來處理合併分支的衝突"</code></li> <li><img alt="用Sourcetree來檢視利用git checkout --ours/--theirs <發生衝突圖的檔案名稱> 來解決合併分支衝突時,若衝突的檔案為圖片時的情況_圖解說明" src=../../assets/pics/git/%E7%94%A8Sourcetree%E4%BE%86%E6%AA%A2%E8%A6%96%E5%88%A9%E7%94%A8git%20checkout%20--ours%3A--theirs%20%3C%E7%99%BC%E7%94%9F%E8%A1%9D%E7%AA%81%E5%9C%96%E7%9A%84%E6%AA%94%E6%A1%88%E5%90%8D%E7%A8%B1%3E%20%E4%BE%86%E8%A7%A3%E6%B1%BA%E5%90%88%E4%BD%B5%E5%88%86%E6%94%AF%E8%A1%9D%E7%AA%81%E6%99%82%2C%E8%8B%A5%E8%A1%9D%E7%AA%81%E7%9A%84%E6%AA%94%E6%A1%88%E7%82%BA%E5%9C%96%E7%89%87%E6%99%82%E7%9A%84%E6%83%85%E6%B3%81_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png></li> </ul> </li> </ul> <h4 id=_9>目前的工作做到一半,如果要臨時切換到別的任務,該怎麼做呢?<a class=headerlink href=#_9 title="Permanent link">&para;</a></h4> <ul> <li><code>情境說明</code></li> <li>假設現在臨時有個重大Bug要修復,但是當下正在<code>develop分支</code>開發新功能,開發到一半; 這時候可以用以下2種方式來處理</li> <li>先<code>commit</code>目前的進度<ul> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "尚未完成的新功能開發分支"</code></li> <li>接下來就可以切換到重大Bug所在的分支(branch)先進行修復,待完成之後再切換回來原來做一半的<code>develop分支</code></li> <li>$ <code>git checkout develop</code></li> <li>再利用<code>Reset</code>回到<code>HEAD</code>指標目前指向的<code>Commit物件</code>("尚未完成的新功能開發分支")的前一次HEAD紀錄,把剛剛開發到一半的東西拆出來繼續開發</li> <li>$ <code>git reset HEAD^</code></li> </ul> </li> <li>利用Git的<code>Stash</code>功能<ul> <li>$ <code>git stash</code>: 將"暫存區"(staging area)的檔案都加到<code>Stash</code>中</li> <li>$ <code>git stash</code> 預設就是相當於 $ <code>git stash push</code> </li> <li><code>-u</code> (=&gt; <code>--include-untracked</code>): 可以加上這個參數,讓<code>工作目錄</code>(working directory)中的<code>Untracked Files</code>也一起加入到<code>Stash</code>中</li> <li><img alt="git stash -u 將所有檔案(包含Untracked Files)的當下狀態都儲存起來" src=../../assets/pics/git/git%20stash%20-u%20%E5%B0%87%E6%89%80%E6%9C%89%E6%AA%94%E6%A1%88%28%E5%8C%85%E5%90%ABUntracked%20Files%29%E7%9A%84%E7%95%B6%E4%B8%8B%E7%8B%80%E6%85%8B%E9%83%BD%E5%84%B2%E5%AD%98%E8%B5%B7%E4%BE%86.png></li> <li>這時候檢視Git狀態,會發現當下的狀態跟剛<code>commit</code>完一樣乾淨</li> <li>$ <code>git stash list</code>: 列出所有目前擁有的<code>Stash</code>項目</li> <li>最前面的<code>stash@{0}</code>就是這個<code>Stash</code>的代名詞</li> <li>後面的<code>WIP on &lt;該分支的名稱&gt;</code>的<code>WIP</code>是"Work In Progress",也就是工作進行中的意思</li> <li><code>Stash</code>可以建立好多個</li> <li><img alt="git stash list 列出目前所有的stash" src=../../assets/pics/git/git%20stash%20list%20%E5%88%97%E5%87%BA%E7%9B%AE%E5%89%8D%E6%89%80%E6%9C%89%E7%9A%84stash.png></li> <li>$ <code>git stash pop stash@{&lt;編號&gt;}</code>: 將某個Stash項目拿出來並套用到目前的分支上; 當套用成功後,該<code>Stash</code>就會被刪除</li> <li>如果使用 $ <code>git stash pop</code>指令,卻沒有指定要套用哪個<code>Stash</code>的話,就會從最小的開始,相當於從<code>stash@{0}</code>開始拿(也就是最後疊上去<code>Stash</code>的那次)</li> <li><img alt="git stash pop stash@{0} 可以用來將某個stash拿出來並套用在目前的分支上" src=../../assets/pics/git/git%20stash%20pop%20stash%40%7B0%7D%20%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BE%86%E5%B0%87%E6%9F%90%E5%80%8Bstash%E6%8B%BF%E5%87%BA%E4%BE%86%E4%B8%A6%E5%A5%97%E7%94%A8%E5%9C%A8%E7%9B%AE%E5%89%8D%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8A.png></li> <li>$ <code>git stash apply stash@{&lt;編號&gt;}</code>: 將某個Stash項目拿出來並套用到目前的分支上; 但是當套用成功後,但"不要"將該<code>Stash</code>刪除,還是會留在<code>Stash List</code>上</li> <li>$ <code>git stash drop stash@{&lt;編號&gt;}</code>: 從<code>Stash List</code>中刪除該<code>Stash</code></li> <li>$ <code>git stash clear</code>: 從<code>Stash List</code>中清除所有的<code>Stash</code></li> </ul> </li> </ul> <h4 id=exgit>如果不小心將機敏資料(ex:帳號、密碼)放在Git裡,想把它刪掉,該怎麼做呢?<a class=headerlink href=#exgit title="Permanent link">&para;</a></h4> <ul> <li>可先參考<a href=#如果有特定檔案不想放在git裡面一起備份或是上傳到git-server的話例如資料庫密碼雲端伺服器的金鑰可以加入-gitignore中>如果有特定檔案不想放在Git裡面一起備份或是上傳到Git Server的話,例如:資料庫密碼,雲端伺服器的金鑰...可以加入 <code>.gitignore</code>中</a></li> <li>首先,如果是已經<code>推送(Push)</code>上去到GitHub上的話,請先不要想要用Git來解決,強烈建議直接先改密碼再說! 改完密碼後,再接著利用Git做後續補救措施</li> <li><code>情境說明</code></li> <li>假設我想要把<code>config/database.yml</code>這個檔案從每個<code>Commit物件</code>裡把它拿掉,比較辛苦的做法是使用 <code>Rebase</code>指令,然後一個一個進去<code>Commit物件</code>去編輯</li> <li>那如果不想使用<code>Rabse指令</code>的方式來處理的話,有以下3種方法可以補救<ul> <li>整個砍掉重練(=&gt;不建議這樣做)</li> <li>$ <code>rm -r .git/</code>: 將整個<code>.git/</code>目錄刪掉</li> <li>把所有含有機敏資料的相關檔案"刪除"或是"修正"</li> <li>重新<code>commit</code>一次<ul> <li>$ <code>git add --all</code></li> <li>$ <code>git commit -m "initial commit"</code></li> </ul> </li> <li>利用 $ <code>git filter-branch</code>指令</li> <li>$ <code>git filter-branch --tree-filter &lt;command&gt;</code><ul> <li>$ <code>git filter-branch</code> 這個指令可以讓你根據不同的<code>filter條件</code>,一個一個應用到每個<code>Commit物件</code>上來處理</li> <li><code>--tree-filter &lt;command&gt;</code>: 會在接下來$ <code>git checkout</code> 的每個Commit物件時,都會執行後面指定的<code>&lt;command&gt;</code>,全部執行完後會再自動重新再<code>commit</code>一次</li> <li>假設是刪除了一個機敏資料的檔案的話,因為是"刪除"的行為,所以對Git來說在那之後的所有<code>Commit物件</code>都要全部重新計算,也就是相當於產生一份新的<code>commit紀錄</code>了</li> <li>備註: 檔案一旦加入Git版控中,要徹底刪除就沒那麼好刪除了</li> <li>例如: $ <code>git filter-branch --tree-filter "rm -f config/database.yml"</code> =&gt; 將<code>config/database.yml</code>這個檔案從每次的Commit物件中刪除</li> <li><img alt="git filter-branch --tree-filter <command> 可以用來將<command>的操作套用到所有的Commit物件上" src=../../assets/pics/git/git%20filter-branch%20--tree-filter%20%3Ccommand%3E%20%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BE%86%E5%B0%87%3Ccommand%3E%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A5%97%E7%94%A8%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84Commit%E7%89%A9%E4%BB%B6%E4%B8%8A.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/faq/remove-sensitive-data.html>https://gitbook.tw/chapters/faq/remove-sensitive-data.html</a></li> </ul> </li> <li>如果又後悔了,想要回復剛剛$ <code>git filter-branch</code>造成的結果以前的狀態,該怎麼辦呢?<ul> <li>原理: 當執行$ <code>git filter-branch</code>指令的時候,Git會幫你把之前的狀態備份一份在 <code>.git/refs/original/refs/heads/</code> 這個目錄裡面</li> <li>其實與其說是備份,也只是備份開始進行<code>filter-branch</code>之前的那個<code>HEAD</code>指向的<code>Commit物件</code>的<code>SHA-1值</code>而已</li> <li>接著就可以利用<code>hard Reset指令</code>直接切回去原來的<code>Commit物件</code>,這樣就都回來了</li> <li>$ <code>git reset .git/refs/original/refs/heads/master --hard</code> </li> <li>可參考<a href=#-git-reset-是用來前往到指定的commit物件上的>$ <code>git reset</code> 是用來"前往"到指定的<code>Commit物件</code>上的</a></li> <li>可參考<a href=#如果想重新編輯剛才的commit>如果想重新編輯剛才的commit</a></li> </ul> </li> <li>利用 $ <code>git push -f</code>:重新"強制"<code>推送(Push)</code>一份你剛剛已經$ <code>git filter-branch</code>過後的<code>commit</code>上去來覆蓋掉它</li> <li>提醒: 因為其實已經<code>推送(Push)</code>出去的東西就跟潑出去的水一樣,收不回來的 </li> </ul> </li> </ul> <h4 id=commit_5>可以只取用某個分支的其中某幾個<code>commit</code>嗎?<a class=headerlink href=#commit_5 title="Permanent link">&para;</a></h4> <ul> <li><code>情境說明</code></li> <li><code>$ git cherry-pick &lt;要取用的Commit物件的id&gt;</code>: 可以只選取指定的<code>commit</code>來用</li> <li>假設在<code>red分支</code>新增一個<code>cherry-pick-test.html</code>檔案,並用<code>cherry-pick指令</code>將這個<code>commit</code>拿來使用,加到目前所在的分支上面<ul> <li>$ <code>git checkout -b red</code>: 新增一個<code>red分支</code>並切換到該分支上</li> <li>$ <code>echo "test $ git cherry-pick" &gt; cherry-pick-test.html</code>: 新增一段文字到測試檔案中</li> <li>$ <code>git commit -a -m "新增git cherry-pick筆記"</code>: 將測試檔案加到<code>暫存區</code>(staging area)並同時提交到<code>儲存庫</code>(repo)</li> <li>$ <code>git checkout master</code>: 切換回<code>master分支</code>上</li> <li>$ <code>git cherry-pick d685d6f</code>: 選取<code>red分支</code>上剛剛提交的那個<code>Commit物件</code>,並將它加到目前所在分支的最前面</li> <li><img alt="git cherry-pick 可以用來選取某個分支的某個commit來使用_統整" src=../../assets/pics/git/git%20cherry-pick%20%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BE%86%E9%81%B8%E5%8F%96%E6%9F%90%E5%80%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E5%80%8Bcommit%E4%BE%86%E4%BD%BF%E7%94%A8_%E7%B5%B1%E6%95%B4.gif></li> </ul> </li> <li><code>$ git cherry-pick &lt;要取用的Commit物件的id 1&gt; &lt;要取用的Commit物件的id 2&gt;</code>: 可以一次選取多個指定的<code>commit</code>來用</li> <li>$ <code>git cherry-pick &lt;要取用的Commit物件的id&gt; --no-commit</code>: 撿過來的<code>commit</code>不會直接合併,而是先放到<code>暫存區</code>(staging area)<ul> <li><code>--no-commit</code>: 撿過來的<code>commit</code>不會直接合併,而是會先放在<code>暫存區</code>(staging area)</li> </ul> </li> </ul> <h4 id=git_11>如何把一個檔案從Git版控中真正的移除掉呢?<a class=headerlink href=#git_11 title="Permanent link">&para;</a></h4> <ul> <li>因為Git是一個分散式的版本控制系統,當檔案被Git版控後,就很難真正的移除掉了</li> <li>想要將已被Git版控的檔案,完全從Git移除掉的話,有以下3種方法可以做到</li> <li><code>情境說明</code></li> <li><img alt=該怎麼完全刪除檔案的commit紀錄_圖解說明 src=../../assets/pics/git/%E8%A9%B2%E6%80%8E%E9%BA%BC%E5%AE%8C%E5%85%A8%E5%88%AA%E9%99%A4%E6%AA%94%E6%A1%88%E7%9A%84commit%E7%B4%80%E9%8C%84_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/faq/remove-files-from-git.html>https://gitbook.tw/chapters/faq/remove-files-from-git.html</a><ul> <li>將整個 <code>.git/</code> 目錄完全移除</li> <li>用<code>Rebase方式</code>進行編輯,重整<code>commit紀錄</code> (=&gt; 適用於當<code>commit紀錄</code>的數量不算多的時候)</li> <li>可參考<a href=#分支branch操作>分支(branch)操作</a>的 $ <code>git rebase -i</code> 章節</li> <li>利用$ <code>git filter-branch --tree-filter &lt;command&gt;</code>,可以大範圍的對每個<code>Commit物件</code>都執行一次該指定的命令(<code>&lt;command&gt;</code>),並於修改完成後再自動重新<code>commit</code></li> <li>例如: <code>$ git filter-branch -f --tree-filter "rm -f config/database.yml"</code><ul> <li>注意! 多加了一個 "<code>-f</code>"參數,是因為要強制覆寫<code>filter-branch</code>的備份點,這邊使用<code>filter-branch</code>指令把檔案從<code>工作目錄</code>(working directory)移除掉,這時候<code>database.yml</code>確實不見了,但還有好幾個跟資源回收有關的事情需要處理</li> <li><code>-f</code> (=&gt; <code>--force</code>): 強制覆寫<code>filter-branch</code>的備份點<blockquote> <p><code>git filter-branch -f</code>: git filter-branch refuses to start with an existing temporary directory or when there are already refs starting with refs/original/, unless forced.</p> </blockquote> </li> </ul> </li> <li>可以參考<a href=#如果不小心將機敏資料ex帳號密碼放在git裡想把它刪掉該怎麼做呢>如果不小心將機敏資料(ex:帳號、密碼)放在Git裡,想把它刪掉,該怎麼做呢?</a></li> <li>因為執行$ <code>git filter-branch</code>指令,所有Git會自動有備份點,隨時可以透過它再跳回去,所以要先斷了這條線</li> <li>$ <code>rm .git/refs/original/refs/heads/master</code></li> <li>$ <code>git reflog expire --all --expire=now</code>: 要求<code>Reflog</code>現在立刻過期(因為<code>Reflog</code>預設會自動保存30天內的紀錄)</li> <li>$ <code>git reflog expire</code>: <code>Reflog</code>的子命令<code>expire</code>會修剪掉過去"舊的" <code>Reflog紀錄</code><blockquote> <p>The "expire" subcommand prunes older reflog entries.</p> </blockquote> </li> <li><code>--all</code> (=&gt; <code>--force</code>): 對所有的<code>Reflog紀錄</code>做處理</li> <li><code>--expire=&lt;time&gt;</code>: 修剪掉比<code>&lt;time&gt;</code>這個時間還"舊"的<code>Reflog紀錄</code></li> <li>$ <code>git fsck --unreachable</code>: 驗證所有的Git物件在<code>.git/objects</code>中,並只顯示出"仍然存在"但是為"Unreachable狀態"的物件</li> <li><code>--unreachable</code>: 僅列出"仍然存在"但是為"Unreachable狀態"的物件</li> <li><img alt="git fsck --unreachable 可以列出在整個 .git/objects 的目錄中所有依然存在但是為Unreachable狀態的物件" src=../../assets/pics/git/git%20fsck%20--unreachable%20%E5%8F%AF%E4%BB%A5%E5%88%97%E5%87%BA%E5%9C%A8%E6%95%B4%E5%80%8B%20.git%3Aobjects%20%E7%9A%84%E7%9B%AE%E9%8C%84%E4%B8%AD%E6%89%80%E6%9C%89%E4%BE%9D%E7%84%B6%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E7%82%BAUnreachable%E7%8B%80%E6%85%8B%E7%9A%84%E7%89%A9%E4%BB%B6.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/faq/remove-files-from-git.html>https://gitbook.tw/chapters/faq/remove-files-from-git.html</a></li> <li>最後,啟動Git的資源回收機制,請垃圾車"現在"來把它們載走</li> <li>$ <code>git gc --prune=now</code>: <ul> <li><code>--prune=&lt;date&gt;</code>: 修剪掉所有比<code>&lt;date&gt;</code>這個時間還"舊"的並且"未受控制"(loose)的物件 </li> </ul> </li> <li>可參考<a href=#git其實不是在做差異備份而是在為當時的專案建立快照snapshot>Git其實不是在做差異備份,而是在為當時的專案建立快照(snapshot)</a>的$<code>git gc</code>章節</li> <li>可以檢查看看是否真的完全刪除了該檔案,可以利用以下2種方法</li> <li>$ <code>git fsck</code><ul> <li><img alt="用git fsck檢查是否真的完全刪除掉該檔案了" src=../../assets/pics/git/%E7%94%A8git%20fsck%E6%AA%A2%E6%9F%A5%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E5%AE%8C%E5%85%A8%E5%88%AA%E9%99%A4%E6%8E%89%E8%A9%B2%E6%AA%94%E6%A1%88%E4%BA%86.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/faq/remove-files-from-git.html>https://gitbook.tw/chapters/faq/remove-files-from-git.html</a></li> </ul> </li> <li>$ <code>git reset &lt;Commit物件的id&gt; --hard</code><ul> <li><img alt="用git reset <Commit物件的id> --hard 來檢查該檔案是否真的完全刪除了" src=../../assets/pics/git/%E7%94%A8git%20reset%20%3CCommit%E7%89%A9%E4%BB%B6%E7%9A%84id%3E%20--hard%20%E4%BE%86%E6%AA%A2%E6%9F%A5%E8%A9%B2%E6%AA%94%E6%A1%88%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E5%AE%8C%E5%85%A8%E5%88%AA%E9%99%A4%E4%BA%86.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/faq/remove-files-from-git.html>https://gitbook.tw/chapters/faq/remove-files-from-git.html</a></li> <li>提醒: 如果這些內容已經<code>推送</code>(Push)出去的話,要記得用$ <code>git push -f</code> 來把線上的紀錄強制蓋掉喔!</li> </ul> </li> </ul> </li> </ul> <hr> <h3 id=-github>遠端共同協作篇---以 GitHub 為例<a class=headerlink href=#-github title="Permanent link">&para;</a></h3> <blockquote> <p><code>GitHub 官方文件</code>(Official Docs) - <a href=https://docs.github.com/en>https://docs.github.com/en</a><br> <code>GitHub 官方網站</code>(Official Website) - <a href=https://github.com/ >https://github.com/</a><br> <code>git remote</code> - Manage set of tracked repositories<br> <code>git push</code> - Update remote refs along with associated objects<br> <code>git pull</code> - Fetch from and integrate with another repository or a local branch<br> <code>git fetch</code> - Download objects and refs from another repository<br> <code>git clone</code> - Clone a repository into a new directory<br> <code>Forking Projects</code> - 如果我們想要對一個在GitHub上已經存在的開源專案做出貢獻(修改),但是我們沒有<code>推送</code>(Push)到這個repository的權限的話,我們可以<code>Fork</code>一份這個專案到自己的GitHub上,成為屬於存在於我們自己的GitHub namespace,這樣我們自己就有權限可以<code>推送</code>(Push)到這個repository上面去了<br> <code>Pull Request</code> - 會發送一個"通知"(<code>PR</code>)給原作者,請求原作者同意將我們之前<code>Fork</code>回來並修改後的內容<code>合併</code>(Merge)到原作者的專案中; 同時原作者也可以不用擔心需要開放編輯權限給所有開發者們而難以管理<br> <code>git format-patch</code> - Prepare patches for e-mail submission<br> <code>git am</code> - Apply a series of patches from a mailbox<br></p> </blockquote> <h4 id=github>GitHub 基礎使用操作說明<a class=headerlink href=#github title="Permanent link">&para;</a></h4> <ul> <li>GitHub是目前全球最大的Git Server,可以幫忙貢獻其他人的專案,並且其他人也可以回饋到你的專案,建立良性循環</li> <li>Git是一個用來做版本控制的軟體,而GitHub是一個網站</li> <li>其中GitHub的本體是一個Git Server,網站則是用Ruby on Rails開發的</li> <li>GitHub於 2019/01 以後,開始可以免費建立private repository</li> </ul> <h4 id=github-repositoryrepositorygithub>新建一個GitHub repository,並推送本地端repository到GitHub上<a class=headerlink href=#github-repositoryrepositorygithub title="Permanent link">&para;</a></h4> <ul> <li>如何建立一個新的GitHub repository呢?</li> <li>官方建議每當新建一個repository時,需包含以下3種檔案<ul> <li><code>README.md</code>: 該repository的使用說明</li> <li><code>LICENSE.md</code>: 該repository的授權範圍</li> <li><code>.gitignore</code>: 該repository指定"不要"追蹤的檔案有哪些?</li> </ul> </li> <li><code>流程如以下說明</code></li> <li>可以選擇要用 <code>HTTPS</code> or <code>SSH</code> 的方式來連線到這個GitHub repository<ul> <li><code>HTTPS</code>:在上傳時需要輸入帳密,如果不需要大多是帳密(Key Chain)已存在電腦內</li> <li><code>SSH</code>: 需要先在電腦內設定好金鑰(SSH key),並儲存這個金鑰到自己的GitHub上,上傳時就不需要輸入額外帳密</li> </ul> </li> <li>如果是全新開始,可以參考官網上的提示 "create a new repository on the command line" 的指示進行<ul> <li>$ <code>echo "# gitLearn" &gt;&gt; README.md</code></li> <li>$ <code>git init</code> </li> <li>$ <code>git add README.md</code></li> <li>$ <code>git commit -m "first commit"</code></li> <li>$ <code>git remote add origin git@github.com:&lt;自己的username&gt;/&lt;要新建的repository的名稱&gt;.git</code></li> <li>$ <code>git remote add</code>: 代表要設定一個遠端(remote)的節點</li> <li><code>origin</code>: 是一個慣用的代名詞,作為遠端節點的預設名稱,指的是後面那串GitHub伺服器的位置</li> <li>如果之後想更改的話,可以直接在輸入一次這個指令更改<ul> <li>例如: $ <code>git remote add superman git@github.com:&lt;自己的username&gt;/&lt;要新建的repository的名稱&gt;.git</code> </li> </ul> </li> <li>$ <code>git push -u origin master</code></li> <li>設定好遠端節點後,就要將東西推送(Push)上去了</li> <li><code>情境說明</code></li> <li>這個指令會將<code>master分支</code>的內容推送到遠端的<code>origin節點</code><ul> <li>如果<code>master分支</code>不存在的話,就會建立一個叫做master的同名分支</li> <li>但如果本來遠端的<code>origin節點</code>就存在master分支的話,便會移動遠端的<code>origin節點</code>上master分支的位置,使它到目前最新的進度上</li> <li><code>-u</code> (=&gt; <code>--set-upstream</code>): 設定<code>upstream</code>; 所謂"上游(upstream)"的概念其實就只是另一個分支的名字而已。在Git裡,每個分支可以設定一個<code>上游(upstream)</code>,但每個分支最多只能設定一個<code>上游(upstream)</code>,它會指向並追蹤(track)某個分支。通常<code>上游(upstream)</code>會是遠端Server上的某個分支,但其實要設定在本地端的其他分支也可以</li> <li>如果有像這個指令設定好後,未來它就會被當作預設值; 以這個指令來看,就會把 <code>origin/master</code> 設定為本地master分支的 <code>上游(upstream)</code>,下次$ <code>git push</code>時,就可以不加任何參數,Git就會預設你是要推送到origin這個遠端節點,並且把master這個分支的內容推送上去</li> <li>例如: $ <code>git push</code></li> </ul> </li> <li>補充1: 如果沒有設定好upstream的話,就必須在每次推送出去時,都要跟Git講清楚<ul> <li>例如: $ <code>git push origin master</code> = $ <code>git push origin master:master</code></li> </ul> </li> <li>補充2: 如果推送上去遠端origin節點時,不想要用跟本地端分支的名稱相同的話,可以採取以下做法<ul> <li>例如: $ <code>git push origin master:dog</code></li> <li>這樣代表當把本地端的master分支推送上去遠端origin節點時,就"不會"建立一個origin/master分支,而是建立(or 更新進度)一個叫做origin/dog的遠端分支</li> </ul> </li> </ul> </li> <li>如果是要上存本機端(local)現存的專案,則可以參考官網上的提示 "push an existing repository from the command line" 的指示進行<ul> <li>$ <code>git remote add origin git@github.com:&lt;自己的username&gt;/&lt;要新建的repository的名稱&gt;.git</code></li> <li>$ <code>git push -u origin master</code></li> </ul> </li> </ul> <h4 id=repositorypull>從遠端repository利用Pull下載並更新<a class=headerlink href=#repositorypull title="Permanent link">&para;</a></h4> <ul> <li>可以利用<code>Pull指令</code>將遠端儲存庫(remote repository)下載回本地端儲存庫(local repository)並更新</li> <li>當執行<code>Fetch指令</code>時,Git會檢查一下遠端repository的版本內容後,將目前遠端repository有,但是目前本地端repository沒有的內容下載一份回來,同時移動origin相關的分支 </li> <li>在原理上, $ <code>git pull</code> = $ <code>git fetch</code> + $ <code>git merge FETCH_HEAD</code></li> <li><code>Fetch指令說明</code><ul> <li>適用情境: 只是想確認遠端數據庫的內容卻不是真的想合併</li> <li>可以取得遠端數據庫的最新歷史記錄; 取得的提交會導入在自動建立的分支中,並可以切換這個名為<code>FETCH_HEAD</code>的分支</li> <li><img alt="git fetch 下載遠端repository的內容" src=../../assets/pics/git/git%20fetch%20%E4%B8%8B%E8%BC%89%E9%81%A0%E7%AB%AFrepository%E7%9A%84%E5%85%A7%E5%AE%B9.png><br> 參考圖片出處<a href=https://backlog.com/git-tutorial/tw/stepup/stepup3_2.html>https://backlog.com/git-tutorial/tw/stepup/stepup3_2.html</a></li> <li>$ <code>git fetch &lt;遠端origin節點&gt;</code>: 將整個遠端origin節點的全部更新,全部下載回來(預設情況是取回所有分支的更新)</li> <li>例如: $ <code>git fetch origin</code></li> <li>$ <code>git fetch &lt;遠端origin節點&gt; &lt;遠端分支的名稱&gt;</code>: 只將遠端origin節點的特定分支(remote branch)的更新下載回來</li> <li>例如: $ <code>git fetch origin master</code> </li> <li>$ <code>git fetch --all</code>: 會從另一個repository下載<code>分支</code>(branch)和<code>標籤</code>(tag)</li> <li><code>--all</code>: 下載全部遠端分支(remote branches)的內容</li> <li><code>情境說明</code></li> <li>因為現在這個專案之前有推送東西到Server上,所以遠端分支也會記錄一份在本機上,一樣也是有<code>HEAD</code>、<code>master分支</code>,但會在前面加註遠端節點origin,變成<code>origin/HEAD</code>、<code>origin/master</code></li> <li>其實之前在<code>Push指令</code>時有加<code>-u</code> (=&gt; <code>--set-upstream</code>)參數,就是用來設定<code>upstream</code>(上游)用的,所以目前這個<code>origin/master</code>遠端分支其實就是本地<code>master分支</code>的upstream喔<ul> <li>可參考<a href=#新建一個github-repository並推送本地端repository到github上>新建一個GitHub repository,並推送本地端repository到GitHub上</a></li> </ul> </li> <li>利用 $ <code>git fetch origin master</code> 將<code>遠端分支</code>(origin/master)下載一份回到本地端的<code>master分支</code>上面 </li> <li>因為這個遠端分支(origin/master)是從master分支分出去的,而且進度還比master分支還要新,可以利用<code>Merge指令</code>合併它們<ul> <li>$ <code>git merge origin/master</code>: 將目前所在的分支合併到<code>遠端分支</code>(origin/master); 就能讓<code>本地端分支</code>(master)跟上<code>遠端分支</code>(origin/master)的進度了</li> <li>可參考<a href=#分支branch操作>分支(branch)操作</a>的$ <code>git merge</code>篇</li> </ul> </li> <li><img alt="git fetch + git merge 的完整流程_統整" src=../../assets/pics/git/git%20fetch%20%2B%20git%20merge%20%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B_%E7%B5%B1%E6%95%B4.gif><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/pull-from-github.html>https://gitbook.tw/chapters/github/pull-from-github.html</a></li> <li>補充1: 其實可以把<code>origin/master</code>這種遠端分支視為一個從原來本地端<code>master分支</code>分出去的一個分支就好了</li> <li>補充2: 因為<code>遠端分支</code>(origin/master)與<code>本地端分支</code>(master)是來自同一個源頭,所以在這次的Merge過程,Git會預設使用<code>快轉模式</code>(fast-forward模式)</li> </ul> </li> <li><code>Pull指令說明</code><ul> <li>$ <code>git pull</code>: 其實就是去遠端origin節點抓東西回來(<code>Fetch</code>),並且更新本機的進度(<code>Merge</code>)而已</li> <li>執行<code>Pull指令</code>時,如果內容沒有衝突,就會自動建立合併提交。如果發生衝突的話,需先解決衝突然後再手動提交</li> <li>也可以只用<code>Rebase方式</code>來合併分支</li> <li>可先參考<a href=#分支branch操作>分支(branch)操作</a>的$ <code>git rebase</code>篇</li> <li>$ <code>git pull --rebase</code>: 指定使用<code>Rebase方式</code>來合併(Merge)下載回來的內容<ul> <li><code>-r</code> (=&gt; <code>--rebase</code>): 當從遠端repository<code>下載(Fetch)</code>回來後,將目前所在的分支(current branch)用<code>Rebase的方式</code>合併到其<code>上游分支</code>(upstream branch)的上面</li> </ul> </li> <li>適用情境: 當不想因為合併分支而多產生一次<code>commit紀錄</code>的話,可以用<code>Rebase方式</code>來合併分支</li> </ul> </li> </ul> <h4 id=pushrepository>為什麼有時候會推送(Push)不上去遠端repository呢?<a class=headerlink href=#pushrepository title="Permanent link">&para;</a></h4> <ul> <li>當<code>遠端origin節點</code>的repository內容比我們的<code>本地端分支</code>的這份內容還要"新"的話,Git就不會讓我們<code>推送</code>(Push)上去</li> <li><img alt="git push 被拒絕,因為遠端repository的內容比本地端分支的內容還要新_圖解說明" src=../../assets/pics/git/git%20push%20%E8%A2%AB%E6%8B%92%E7%B5%95%2C%E5%9B%A0%E7%82%BA%E9%81%A0%E7%AB%AFrepository%E7%9A%84%E5%85%A7%E5%AE%B9%E6%AF%94%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%88%86%E6%94%AF%E7%9A%84%E5%85%A7%E5%AE%B9%E9%82%84%E8%A6%81%E6%96%B0_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/fail-to-push.html>https://gitbook.tw/chapters/github/fail-to-push.html</a></li> <li>有時候是因為多人共同協作時,當<code>遠端origin節點</code>的分支已經先被某人更新時,這時候其他人就會發生<code>推送</code>(Push)不上去的情況</li> <li>如同以下情況 </li> <li><img alt="git push 被拒絕-多人共同協作時會遇到的情況_圖解說明" src=../../assets/pics/git/git%20push%20%E8%A2%AB%E6%8B%92%E7%B5%95-%E5%A4%9A%E4%BA%BA%E5%85%B1%E5%90%8C%E5%8D%94%E4%BD%9C%E6%99%82%E6%9C%83%E9%81%87%E5%88%B0%E7%9A%84%E6%83%85%E6%B3%81_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/fail-to-push.html>https://gitbook.tw/chapters/github/fail-to-push.html</a></li> <li>這時候會有2種方式可以無法<code>推送</code>(Push)的問題</li> <li>方法一: 先更新本地端儲存庫(local repository)的內容,再推送上去遠端儲存庫(remote repository)一次<ul> <li>$ <code>git pull --rebase</code>: 將<code>遠端origin節點</code>的repository下載回來後,指定要用<code>Rebase方式</code>來合併</li> <li><code>--rebase</code>: 將目前所在的分支rebase到<code>遠端origin節點</code>的<code>上游分支</code>(upstream branch)的"上面"</li> <li>此時如果合併沒有發生衝突的話,就可以順利的往上<code>推送</code>(Push)了</li> <li><img alt="git push --rebase 指定要用Rebase的方式更新本地端repository的內容後,再推送上去遠端儲存庫一遍" src=../../assets/pics/git/git%20push%20--rebase%20%E6%8C%87%E5%AE%9A%E8%A6%81%E7%94%A8Rebase%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0%E7%AB%AFrepository%E7%9A%84%E5%85%A7%E5%AE%B9%E5%BE%8C%2C%E5%86%8D%E6%8E%A8%E9%80%81%E4%B8%8A%E5%8E%BB%E9%81%A0%E7%AB%AF%E5%84%B2%E5%AD%98%E5%BA%AB%E4%B8%80%E9%81%8D.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/fail-to-push.html>https://gitbook.tw/chapters/github/fail-to-push.html</a></li> </ul> </li> <li>方法二: 無論規則,強制<code>推送</code>(Push)上去<ul> <li>$ <code>git push -f</code>: 強制將目前<code>本地端repository</code>的內容推送到<code>遠端origin節點</code>的repository上面,同時會將原本遠端repository的內容"覆蓋掉"</li> <li><code>-f</code> (=&gt; <code>--force</code>): "強制"執行<code>推送</code>(Push)指令</li> <li>注意! 此方法要慎用,因為會覆蓋掉原本遠端repository的內容</li> <li><img alt="git push -f 強制將本地端儲存庫的內容推送到遠端儲存庫上面去,並覆蓋掉原本遠端repository的內容" src=../../assets/pics/git/git%20push%20-f%20%E5%BC%B7%E5%88%B6%E5%B0%87%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%84%B2%E5%AD%98%E5%BA%AB%E7%9A%84%E5%85%A7%E5%AE%B9%E6%8E%A8%E9%80%81%E5%88%B0%E9%81%A0%E7%AB%AF%E5%84%B2%E5%AD%98%E5%BA%AB%E4%B8%8A%E9%9D%A2%E5%8E%BB%2C%E4%B8%A6%E8%A6%86%E8%93%8B%E6%8E%89%E5%8E%9F%E6%9C%AC%E9%81%A0%E7%AB%AFrepository%E7%9A%84%E5%85%A7%E5%AE%B9.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/fail-to-push.html>https://gitbook.tw/chapters/github/fail-to-push.html</a></li> </ul> </li> </ul> <h4 id=repository>從伺服器上複製遠端repository下來<a class=headerlink href=#repository title="Permanent link">&para;</a></h4> <ul> <li>可以利用$ <code>git clone &lt;HTTPS or SSH&gt;</code> 指令來將遠端的repository複製一份到本地端來檢視</li> <li>可先參考<a href=#新建一個github-repository並推送本地端repository到github上>新建一個GitHub repository,並推送本地端repository到GitHub上</a>的 HTTPS 與 SSH 的比較</li> <li>方法一: 利用HTTPS的方式複製<ul> <li>$ <code>git clone https://github.com/Hans-Tsai/gitLearn.git</code></li> <li>此方法使用者只要當下輸入 <code>帳號</code> &amp; <code>密碼</code> 就可以複製了</li> </ul> </li> <li>方法二: 利用SSH的方式複製<ul> <li>$ <code>git clone git@github.com:Hans-Tsai/gitLearn.git</code></li> <li>此方法需事先在本地端產生SSH金鑰後,再到GitHub的Settings做設定; 完成後會如同以下畫面</li> <li><img alt=GitHub的SSH金鑰設定完成後的畫面 src=../../assets/pics/git/GitHub%E7%9A%84SSH%E9%87%91%E9%91%B0%E8%A8%AD%E5%AE%9A%E5%AE%8C%E6%88%90%E5%BE%8C%E7%9A%84%E7%95%AB%E9%9D%A2.png></li> <li>設定GitHub SSH金鑰認證的詳細作法可以參考GitHub的官方文件說明<br> 連結: <a href=https://docs.github.com/en/enterprise-server@2.20/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account>https://docs.github.com/en/enterprise-server@2.20/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account</a></li> </ul> </li> <li>此處的<code>Clone指令</code>的用途,不單純只有複製所有實體檔案,同時也包含複製了整個專案的以下內容</li> <li>歷史紀錄(log &amp; Reflog)</li> <li>分支(Branch)</li> <li>標籤(Tag)</li> <li>如果想要複製下來後,重新命名這個repository的話,可以利用以下指令</li> <li>$ <code>git clone git@github.com:Hans-Tsai/gitLearn.git &lt;新命名的分支名稱&gt;</code></li> <li>在Git Version 1.7.10之後,如果想要只單純地從遠端repository複製特定的分支下來到本機端的話,可以利用以下指令</li> <li>$ <code>git clone -b &lt;指定要複製的分支名稱&gt; --single-branch git@github.com:Hans-Tsai/gitLearn.git</code></li> <li><code>-b &lt;指定的分支名稱&gt;</code> (=&gt; <code>--branch &lt;指定的分支名稱&gt;</code>): Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository’s HEAD, point to <name> branch instead. In a non-bare repository, this is the branch that will be checked out. --branch can also take tags and detaches the HEAD at that commit in the resulting repository.</li> <li><code>--single-branch</code>: 只複製該指定要複製的分支的"最新"<code>歷史commit紀錄</code>,可以搭配<code>--branch</code>參數來使用</li> </ul> <h4 id=clone-pull>Clone(複製) 和 Pull(拉下來更新) 有什麼不同呢?<a class=headerlink href=#clone-pull title="Permanent link">&para;</a></h4> <ul> <li><code>Clone(複製)</code></li> <li><code>使用情境</code></li> <li>當這個專案是第一次看到,我們想要"複製"一份到本地端來看看的時候可以用<code>Clone(複製)指令</code></li> <li>$ <code>git clone &lt;remote repo by HTTPS or SSH&gt;</code>: 從遠端repository複製一份這個專案到本地端的電腦 </li> <li><code>Pull(拉下來更新)</code></li> <li><code>使用情境</code></li> <li>當這個專案我已經下載回來了(本地端已經有一份這個專案了)的時候,只想要"更新"到該專案最新版的遠端repository的內容的話,這時候可以使用<code>Pull(拉下來更新)指令</code></li> <li>$ <code>git pull &lt;遠端節點名稱(ex: origin)&gt; &lt;要合併到目前所在分支上面的遠端分支名稱&gt;</code>: 從遠端repository<code>拉下來(Fetch)</code>一份到本地端且<code>合併(Merge)</code>到目前所在的分支上面</li> </ul> <h4 id=pull-request>利用Pull Request來跟其它開發者的開源專案做互動<a class=headerlink href=#pull-request title="Permanent link">&para;</a></h4> <ul> <li>因為我們沒有權限來<code>推送</code>(Push)更新到GitHub上面別人的專案上,<code>Fork</code>可以用來將GitHub上別的開發者寫的開源專案,"複製"一份到我們自己的GitHub namespace上,這樣我們就有權限可以<code>推送</code>(Push)更新到這個專案上了</li> <li><code>Fork</code>的流程介紹</li> <li>先複製(Fork)一份原作的專案到你自己的GitHub帳號底下<ul> <li><img alt="GitHub Fork別人的專案的按鈕" src=../../assets/pics/git/GitHub%20Fork%E5%88%A5%E4%BA%BA%E7%9A%84%E5%B0%88%E6%A1%88%E7%9A%84%E6%8C%89%E9%88%95.png></li> </ul> </li> <li>因為這個複製回來的專案已經在你自己的GitHub帳號下,所以你就有完整的權限,想怎麼改就怎麼改<ul> <li>$ <code>git clone &lt;自己GitHub上剛剛Fork回來的那個repository&gt;</code></li> </ul> </li> <li>改完後,先推回(Push)"你自己帳號"的專案<ul> <li>$ <code>git push</code></li> </ul> </li> <li>然後發個"通知"(Pull Request),讓原作者知道你有幫忙做了一些事情,請他看一下<ul> <li>這就是<code>Pull Request</code>,<code>Pull Requset</code>其實就是發一個請求請原作者拉回去(<code>Pull</code>)的請求(<code>Request</code>),可以簡稱為"PR"</li> <li><img alt="GitHub 檢視Pull Request的頁面" src=../../assets/pics/git/GitHub%20%E6%AA%A2%E8%A6%96Pull%20Request%E7%9A%84%E9%A0%81%E9%9D%A2.png></li> <li>回到自己的專案頁面,點選"New pull request"的按鈕,再點選"Create pull request"的按鈕後,可以選擇要<code>PR</code>到原作的哪個分支</li> <li><img alt="當按下Create pull request按鈕後就可以新建一個PR" src=../../assets/pics/git/%E7%95%B6%E6%8C%89%E4%B8%8BCreate%20pull%20request%E6%8C%89%E9%88%95%E5%BE%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%96%B0%E5%BB%BA%E4%B8%80%E5%80%8BPR.png></li> </ul> </li> <li>原作者看完後說"我覺得可以",然後就決定把你做的這些修改合併(<code>Merge</code>)到他的專案裡<ul> <li>當原作者覺得這次的修改沒問題的話,就可以收下這次的<code>PR</code>,點選"Merge pull request"的按鈕後,就會合併(<code>Merge</code>)這次的commit了</li> </ul> </li> <li>可參考官方文件提供的<code>Fork</code>流程 <a href=https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/fork-a-repo>https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/fork-a-repo</a></li> <li>可參考官方文件提供的<code>Pull Request</code>流程 <a href=https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/about-pull-requests>https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/about-pull-requests</a></li> <li>在多人共同協作的實戰情境中,通常會先挑選固定一個分支作為可以上線的正式版本分支,慣例上常會挑選<code>master</code>分支或是<code>production</code>分支作為正式分支; 每位開發者都會先從公司的專案<code>Fork</code>一份到自己的GitHub帳號裡面,再下載到本機端進行開發,待開發的功能完成後再發<code>PR</code>回公司的專案,此時負責管理這個專案的人收到<code>PR</code>後,可以開始進行<code>Code Review</code>,並確認無誤後便可進行合併,這樣做的優點是可以保持讓這個產品的分支處於隨時都可以上線的狀態</li> </ul> <h4 id=fork>如何跟上當初Fork的專案的進度呢?<a class=headerlink href=#fork title="Permanent link">&para;</a></h4> <ul> <li>當原作者先收下別人的<code>Pull Request</code>時,該專案的進度就會比在我們自己帳號底下的進度還要前面了; 這時如果想要讓自己帳號底下<code>Fork</code>過來的這個專案"跟上"原作專案的目前的進度的話,可以利用以下2種方法</li> <li>也可以先參考<a href=#為什麼有時候會推送push不上去遠端repository呢>為什麼有時候會推送(Push)不上去遠端repository呢?</a></li> <li>方法一: 砍掉重新<code>Fork</code>一遍<ul> <li>可參考<a href=#利用pull-request來跟其它開發者的開源專案做互動>利用Pull Request來跟其它開發者的開源專案做互動</a>的<code>Fork流程介紹</code>篇</li> </ul> </li> <li>方法二: 跟上游同步<ul> <li>先設定原作的遠端節點</li> <li>$ <code>git remote -v</code>: 可以列出遠端節點的url</li> <li><code>-v</code> (=&gt; <code>--verbose</code>): 詳細列出遠端節點的名稱與url</li> <li><img alt="利用git remote -v 來列出遠端節點的url" src=../../assets/pics/git/%E5%88%A9%E7%94%A8git%20remote%20-v%20%E4%BE%86%E5%88%97%E5%87%BA%E9%81%A0%E7%AB%AF%E7%AF%80%E9%BB%9E%E7%9A%84url.png></li> <li>$ <code>git remote add &lt;遠端節點的名稱&gt; &lt;遠端節點repository的url&gt;</code>: 新增另一個遠端節點名稱與url,而這個遠端節點指的位置就是"原作的專案"</li> <li>可參考<a href=#新建一個github-repository並推送本地端repository到github上>新建一個GitHub repository,並推送本地端repository到GitHub上</a>的$ <code>git remote add</code>篇</li> <li>抓取原作專案的內容</li> <li>$ <code>git fetch &lt;剛剛設定好的新的指向原作專案的遠端節點的名稱&gt;</code>: 利用<code>Fetch</code>指令來取得原作專案最新版的內容</li> <li>$ <code>git merge &lt;要合併到的分支名稱&gt;</code>: 利用<code>Merge</code>指令合併到<code>遠端節點</code>(原作專案)的遠端分支上面</li> <li>例如: $ <code>git merge test_origin/master</code></li> <li>這樣一來我們本機的進度就跟原作的是一樣了</li> <li>如果想要自己在GitHub上那個<code>Fork</code>過來的專案進度也更新到最新版的話,只要將現在本機端的專案<code>推送</code>(Push)上去就好了</li> <li>$ <code>git push origin master</code></li> <li>這樣一來,在我們電腦裡的專案,以及在GitHub上從原作那邊<code>Fork</code>過來的專案都會是最新的進度了</li> </ul> </li> </ul> <h4 id=_10>如何刪除遠端分支呢?<a class=headerlink href=#_10 title="Permanent link">&para;</a></h4> <ul> <li>其實要刪除遠端分支可以透過GitHub上各個Repository最上面的branches圖案點進去後,就可以刪除遠端分支了(垃圾桶圖案)</li> <li><img alt=透過GitHub上的圖形化介面來刪除遠端分支 src=../../assets/pics/git/%E9%80%8F%E9%81%8EGitHub%E4%B8%8A%E7%9A%84%E5%9C%96%E5%BD%A2%E5%8C%96%E4%BB%8B%E9%9D%A2%E4%BE%86%E5%88%AA%E9%99%A4%E9%81%A0%E7%AB%AF%E5%88%86%E6%94%AF.png></li> <li>也可以透過Git指令來刪除遠端分支</li> <li>$ <code>git push &lt;遠端節點的名稱&gt; &lt;要記得在這邊空一格&gt;:&lt;要刪除的遠端分支的名稱&gt;</code>: 其實可以透過<code>推送</code>(Push)時重新命名遠端分支的名稱時,來達到刪除遠端分支的效果</li> <li>可參考<a href=#新建一個github-repository並推送本地端repository到github上>新建一個GitHub repository,並推送本地端repository到GitHub上</a> 的補充2(如何在推送時重新命名一個遠端分支的名稱呢?) 篇</li> </ul> <h4 id=git-push-f-pushrepository>什麼時機適合用$ <code>git push -f</code> 來強制推送(Push)上去到遠端repository呢?<a class=headerlink href=#git-push-f-pushrepository title="Permanent link">&para;</a></h4> <ul> <li>當想要整理Git歷史紀錄or只會影響到自己一人時,可以使用強制推送( <code>$ git push -f</code> )的指令</li> <li>整理歷史紀錄時,有時候會遇到該專案的<code>commit紀錄</code>非常混亂,於是我們使用了<code>Rebase的方式</code>來修改<code>commit的歷史紀錄</code>,但是因為<code>Rebase</code>相當於修改已經發生的事實,所以正常來說會<code>推送</code>(Push)不上去,這時候就可以使用強制推送( <code>$ git push -f</code> )的指令</li> <li>當自己要開發一個新功能並從遠端的repository "開了一個新的分支" 出來開發,但是開發完後同樣發現commit紀錄太過瑣碎了,想利用<code>Rebase的方式</code>來修改<code>commit的歷史紀錄</code>,但是因為<code>Rebase</code>相當於修改已經發生的事實,所以正常來說會<code>推送</code>(Push)不上去,"但因為這個歷史紀錄影響的範圍只有我一個人,所以並不影響其他人正常使用",所以這時候就可以使用強制推送( <code>$ git push -f</code> )的指令<ul> <li>例如: $ <code>git push -f origin features/my_branch</code></li> <li>這樣只會強制更新<code>features/my_branch</code>這個分支的內容,並不會影響其它分支。</li> </ul> </li> <li>也可以使用GitHub提供的保護機制,可以避免某個分支被<code>強制推送</code>(Force Push)來更新</li> <li>可以到該專案的<code>Settings</code>頁籤,左邊選擇<code>Branches</code>,接著可以選擇想要保護的分支,並設定要保護的規則</li> <li>如以下圖例說明</li> <li><img alt="GitHub提供的Branch protection rules功能,來防止指定的分支被強制推送來更新" src=../../assets/pics/git/GitHub%E6%8F%90%E4%BE%9B%E7%9A%84Branch%20protection%20rules%E5%8A%9F%E8%83%BD%2C%E4%BE%86%E9%98%B2%E6%AD%A2%E6%8C%87%E5%AE%9A%E7%9A%84%E5%88%86%E6%94%AF%E8%A2%AB%E5%BC%B7%E5%88%B6%E6%8E%A8%E9%80%81%E4%BE%86%E6%9B%B4%E6%96%B0.png></li> <li><img alt="GitHub提供的Branch protection rule功能的詳細規則介紹_圖解說明" src=../../assets/pics/git/GitHub%E6%8F%90%E4%BE%9B%E7%9A%84Branch%20protection%20rule%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A9%B3%E7%B4%B0%E8%A6%8F%E5%89%87%E4%BB%8B%E7%B4%B9_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/using-force-push.html>https://gitbook.tw/chapters/github/using-force-push.html</a></li> <li>萬一利用$ <code>git push -f</code> 來強制推送(Push)上去到遠端repository後又後悔了的話,可以換你或是其它有之前進度的隊友,再次進行$ <code>git push -f</code> 指令一次,把正確的內容強迫推上去,蓋掉前一次的$ <code>git push -f</code> 指令所造成的災難</li> <li>可參考<a href=#為什麼有時候會推送push不上去遠端repository呢>為什麼有時候會推送(Push)不上去遠端repository呢?</a>的 方法二: 無論規則,強制<code>推送</code>(Push)上去 篇</li> </ul> <h4 id=patchrepository>如何透過<code>更新檔</code>(Patch)來更新本機端的repository的內容呢?<a class=headerlink href=#patchrepository title="Permanent link">&para;</a></h4> <ul> <li>在Git和許多版本控制的軟體還沒有誕生以前,開發者們必須透過Email來寄送更新檔案</li> <li>但是有了Git之後,也可以利用$ <code>git format-patch</code> 指令來產生<code>更新檔</code>(Patch)</li> <li>$ <code>git format-patch &lt;某個Commit物件的id&gt; &lt;某個Commit物件的id&gt;</code>: 產生一份更新檔,範圍是從前者的<code>Commit物件</code>到後者的<code>Commit物件</code>為止,但"不包含"前者的<code>Commit物件</code>本身<ul> <li>如同以下圖片示範</li> <li><img alt="利用git format-patch 來產生更新檔" src=../../assets/pics/git/%E5%88%A9%E7%94%A8git%20format-patch%20%E4%BE%86%E7%94%A2%E7%94%9F%E6%9B%B4%E6%96%B0%E6%AA%94.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/patch.html>https://gitbook.tw/chapters/github/patch.html</a></li> </ul> </li> <li>也可以指定相對的$ <code>git log</code> 的<code>commit紀錄</code>的範圍<ul> <li>$ <code>git format-patch -2</code>: 這樣Git會幫忙產生最新的3次<code>commit紀錄</code>的<code>更新檔</code>(Patch)</li> </ul> </li> <li>也可以指定產生的<code>更新檔</code>(Patch)的位置<ul> <li>$ <code>git format-patch -2 -o &lt;更新檔要存放的檔案位置&gt;</code>: 這樣Git會幫忙產生最新的3次<code>commit紀錄</code>的<code>更新檔</code>(Patch),並指定將<code>更新檔</code>(Patch)存放在指定的位置</li> <li>如同以下圖片示範</li> <li><img alt="利用git format-patch 來產生更新檔並指定更新檔要儲存的位置" src=../../assets/pics/git/%E5%88%A9%E7%94%A8git%20format-patch%20%E4%BE%86%E7%94%A2%E7%94%9F%E6%9B%B4%E6%96%B0%E6%AA%94%E4%B8%A6%E6%8C%87%E5%AE%9A%E6%9B%B4%E6%96%B0%E6%AA%94%E8%A6%81%E5%84%B2%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/github/patch.html>https://gitbook.tw/chapters/github/patch.html</a></li> </ul> </li> <li>可以利用$ <code>git am</code> 指令來<code>應用</code>(Apply)<code>更新檔</code>(Patch)</li> <li>$ <code>git am &lt; 更新檔存放的檔案位置路徑/* &gt;</code>: 表示要將該路徑下的<code>所有更新檔</code>(Patches)都應用到現在的專案上</li> <li>可以一次<code>應用</code>(Apply)一個更新檔,也可以一次<code>應用</code>(Apply)所有更新檔</li> <li>Git會依據檔案的名字"依序"一個一個套用在現有的專案上面</li> </ul> <hr> <h3 id=git_12>Git 常見的團隊工作流程 &amp; 規範<a class=headerlink href=#git_12 title="Permanent link">&para;</a></h3> <blockquote> <p><code>GitHub Guides</code>(Official Guides) - <a href=https://guides.github.com/ >https://guides.github.com/</a><br></p> </blockquote> <h4 id=git-flow>Git Flow介紹<a class=headerlink href=#git-flow title="Permanent link">&para;</a></h4> <ul> <li><code>Git Flow</code>最早是在西元2010年被提出的,<code>Git Flow</code>是一套團隊共同協作的工作流程,以讓團隊內的成員可以有一個能共同遵循的 "開發" &amp; "維運" 流程</li> <li>特色: <code>Git Flow</code>流程會有<code>master</code>、<code>develop</code>、<code>hotfix</code>、<code>release</code>、<code>feature</code>這五種分支,各種分支負責不同的功能,其中<code>master</code>、<code>develop</code>這兩個分支又被稱作長期分支,因為他們會一直存活在整個<code>Git Flow</code>裡,而其它的分支大多會因任務結束而被刪除</li> <li>以下是<code>Git Flow</code>流程圖</li> <li><img alt="Git Flow流程圖_圖解說明" src=../../assets/pics/git/Git%20Flow%E6%B5%81%E7%A8%8B%E5%9C%96_%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/chapters/gitflow/why-need-git-flow.html>https://gitbook.tw/chapters/gitflow/why-need-git-flow.html</a></li> <li>以下介紹<code>Git Flow</code>流程中會碰到的五大分支</li> <li><code>長期分支</code> <ul> <li><code>Master</code> 分支(= 主分支): 主要是用來放穩定、隨時可上線的版本。<strong>這個分支的來源只能從別的分支合併過來,開發者不會直接commit 到這個分支</strong>。因為是穩定版本,所以通常也會在這個分支上的commit上打上版本號標籤</li> <li><code>Develop</code> 分支(= 開發分支): 主要是所有開發的基礎分支。當有新的功能需要開發的時候,<strong>所有的Feature分支都是從這邊切出去</strong>。而當<code>Feature分支</code>的新功能完成後,也都會合併回來這個分支</li> </ul> </li> <li><code>短期分支</code><ul> <li><code>Hotfix</code> 分支(= 修復分支): 當線上產品發生緊急問題的時候,會**從Master分支開一個Hotfix分支出來**進行修復,當<code>Hotfix分支</code>修復完成之後,<strong>會合併回Master分支,也同時會合併一份到Develop分支</strong></li> <li>說明1: 之所以要從<code>Master分支</code>切出來修復是因為<code>Develop分支</code>可能尚在開發中,這時候如果從<code>Develop分支</code>切出去再修復的話,要併回<code>Master分支</code>時,很可能會遇到合併衝突的問題</li> <li>說明2: 之所以要當修復完時,要合併回<code>Develop分支</code>是因為假設之後<code>Develop分支</code>的新功能開發完成後,並且也合併回到<code>Master分支</code>的時候,這時候<code>Hotfix</code>遇到的問題又會再度浮現 </li> <li><code>Release</code> 分支(= 預發分支): 當認為<code>Develop分支</code>夠成熟了,就可以**把<code>Develop分支</code>合併到<code>Release分支</code>,在這邊進行算是上線前的最後測試**。<strong>測試完成後,<code>Release分支</code>將會同時合併到<code>Master</code>以及<code>Develop</code>這兩個分支上</strong></li> <li>說明1: 因為<code>Master分支</code>是上線版本,所以要合併到<code>Master分支</code></li> <li>說明2: 而合併回<code>Develop分支</code>的目的,是因為可能在<code>Release分支</code>上還會測到並修正一些問題,所以需要跟<code>Develop分支</code>同步,免得之後的版本又再度出現同樣的問題</li> <li><code>Feature</code> 分支(= 功能分支): 當要開始**新增功能的時候,就是使用<code>Feature分支</code>的時候了**。<strong><code>Feature分支</code>都是從<code>Develop分支</code>來的,完成之後會再併回<code>Develop分支</code></strong></li> </ul> </li> <li>關於Git Flow 流程的介紹可以參考以下的文章</li> <li><a href=https://github.com/nvie/gitflow><code>Git Flow</code>專案on GitHub</a></li> <li><a href=https://nvie.com/posts/a-successful-git-branching-model/ >A successful Git branching model</a></li> </ul> <h4 id=github-flow>GitHub Flow介紹<a class=headerlink href=#github-flow title="Permanent link">&para;</a></h4> <ul> <li><code>Github Flow</code>是一個適合15–20人左右團隊，在部署上自動化且一天之內會需要多次部署的開發(持續發布)</li> <li>特色: <code>GitHub Flow</code>是一個輕量型、以分支為基礎的工作流程,可以讓我們的團隊與專案更有規律地部署<blockquote> <p>GitHub flow is a lightweight, branch-based workflow that supports teams and projects where deployments are made regularly. --- by 官方文件<br></p> </blockquote> </li> </ul> <blockquote> <p>There's only one rule: anything in the main branch is always deployable. --- --- by 官方文件<br> - <code>GitHub Flow</code>官方文件介紹 + <code>前置流程</code>: * 要先將遠端的repository利用<code>Fork</code>的方式複製到自己的GitHub repository * 將該<code>Fork</code>過來的專案<code>Clone</code>(複製)到自己本機端(local)的電腦上 + <code>CREATE A BRANCH</code>: 在自己本機端(local)的<code>Fork</code>過來的專案上,建立一個新的分支,以讓我們安全的做開發和調整 * 包含$ <code>git add</code> * 包含$ <code>git commit -m</code> + <code>OPEN A PULL REQUEST</code>: 利用<code>Pull Request</code>機制來 發出/收到 全世界的其他開發者的回饋(feedback) * 包含 <code>Conversation</code> * 包含 <code>Code Review</code> + <code>MERGE AND DEPLOY</code>: <code>合併</code>(Merge)這次<code>Pull Request</code>的修改內容到原作者的遠端repository上,並且<code>部署</code>(Deploy)這次的修改變化到原作者的遠端repository上 + 以下是<code>GitHub Flow</code>官方的流程圖說明 * <img alt="GitHub Flow流程_官方圖解說明" src=../../assets/pics/git/GitHub%20Flow%E6%B5%81%E7%A8%8B_%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://guides.github.com/pdfs/githubflow-online.pdf>https://guides.github.com/pdfs/githubflow-online.pdf</a> + 關於GitHub Flow 流程的介紹可以參考以下的文章 * <a href=https://guides.github.com/introduction/flow/ ><code>GitHub Flow</code> 官方圖解說明</a> <br> - <code>GitHub Flow</code>民間介紹 + GitHub 比 Git 有多兩個服務,一個是<code>Fork</code>,另一個是<code>Pull Request</code>(簡稱PR),還新增<code>issue tracking</code>用法 * <code>issue tracking</code>: 開發時,可以給專案標記<code>issue</code>,還有其他不同標籤,還優化專案。當提交的時候,如果提交訊息中有 <strong>fix <a class="magiclink magiclink-github magiclink-issue" href=https://github.com/squidfunk/mkdocs-material/issues/1 title="GitHub Issue: squidfunk/mkdocs-material #1">#1</a></strong> 等,可以自動對應到相關編號的<code>issue</code> * 關於<code>issue tracking</code>的用法說明,可參考<br> <a href=https://guides.github.com/features/issues/ >https://guides.github.com/features/issues/</a> or <br> <a href=https://github.com/g0v/dev/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Issue-Tracker-%E5%9B%9E%E5%A0%B1%E5%95%8F%E9%A1%8C%E3%80%81%E6%8F%90%E4%BA%A4%E5%BB%BA%E8%AD%B0>https://github.com/g0v/dev/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Issue-Tracker-%E5%9B%9E%E5%A0%B1%E5%95%8F%E9%A1%8C%E3%80%81%E6%8F%90%E4%BA%A4%E5%BB%BA%E8%AD%B0</a> + <code>GitHub Flow</code>的流程說明 * 先有一個共有的遠端倉庫(remote repository) * 然後各自用<code>Fork</code>把遠端倉庫<code>Fork</code>回到自己的倉庫(repository) * 從<code>master分支</code>拉出新分支,<code>修改</code>且<code>提交</code>(Commits) * 開發好後,再利用<code>Pull Request</code>機制來發一個通知回去共有的遠端倉庫(remote repository)的原作者 * 待審核過後再<code>合併</code>(Merge)進原作者的遠端倉庫的<code>master分支</code> * 合併後,<code>Pull Request</code>保存了當時的修改歷史記錄以及回饋,可以讓任開發人回頭檢視當初情況 + 以下是<code>GitHub Flow</code>民間的流程圖說明 * <img alt="GitHub Flow流程圖_民間圖解說明" src=../../assets/pics/git/GitHub%20Flow%E6%B5%81%E7%A8%8B%E5%9C%96_%E6%B0%91%E9%96%93%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://medium.com/@lf2lf2111/%E4%B8%89%E7%A8%AE%E7%89%88%E6%8E%A7%E6%B5%81%E7%A8%8B-29c82f5d4469>https://medium.com/@lf2lf2111/%E4%B8%89%E7%A8%AE%E7%89%88%E6%8E%A7%E6%B5%81%E7%A8%8B-29c82f5d4469</a></p> </blockquote> <h4 id=gitlab-flow>GitLab Flow介紹<a class=headerlink href=#gitlab-flow title="Permanent link">&para;</a></h4> <ul> <li><code>GitLab flow</code>分成兩種情況來應付不同的開發流程</li> <li>持續發布(<code>Environment Branches</code> &amp; <code>Upstream First</code>)</li> <li>版本發布(<code>Release Branches</code> &amp; <code>Upstream First</code>)</li> <li>特色: <code>GitLab Flow</code>有一個最主要的原則就是"上游優先"(<code>upstream first</code>),所謂**上游優先**原則的意思是**只存在一個主分支master,此分支為所有其它的分支的上游,也就是說所有的分支都是由主分支(master分支)建立**; 所以分支合併的順序很重要,要一次和並且確保"通過測試"才可以往下游合併,除非是緊急情況,才可以允許跳過上游直接在下游操作合併</li> <li>如以下的官方圖解說明 </li> <li><img alt="GitLab Flow流程_Production branch with GitLab flow_官方圖解說明" src=../../assets/pics/git/GitLab%20Flow%E6%B5%81%E7%A8%8B_Production%20branch%20with%20GitLab%20flow_%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems>https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems</a></li> <li>接下來要介紹<code>GitLab Flow</code>的兩種情境的工作流程(<code>workflow</code>)</li> <li>持續發布(<code>Environment Branches</code> &amp; <code>Upstream First</code>)<ul> <li>持續發布的專案,會建議再多出一個分支,為<code>預發分支</code>(pre-production)</li> <li>每個環境(如開發環境、預發環境、測試環境…等)都會有對應的分支。如下圖,開發環境為master分支,預發環境為<code>pre-production分支</code>,生產環境為<code>production分支</code></li> <li>由下圖來舉例,如果<code>生產環境</code>(production)發生錯誤,則要建一個新分支修改完後合併到最上游的<code>開發分支</code>(master),且**經過測試**,再繼續往<code>預發分支</code>合併(pre-production),都要經過測試沒問題後才能夠再往下<code>合併</code>(Merge)到<code>生產環境</code>。</li> <li><img alt="GitLab Flow流程_Environment branches with GitLab flow_官方圖解說明" src=../../assets/pics/git/GitLab%20Flow%E6%B5%81%E7%A8%8B_Environment%20branches%20with%20GitLab%20flow_%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems>https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems</a></li> </ul> </li> <li>版本發布(<code>Release Branches</code> &amp; <code>Upstream First</code>)<ul> <li>在<code>GitLab Flow</code>中,對於**版本發布**的項目,建議每一個穩定的版本都要從<code>master分支</code>拉出來創建一個新分支,比如下圖的<code>2–3-stable</code>、<code>2–4-stable</code>(release分支)</li> <li>根據對應的<code>release分支</code>再創建一個<code>修復分支</code>,<strong>修補bug後,一樣要照著上游優先規則</strong>,先<code>合併</code>(Merge)到<code>master分支</code>,<strong>確認沒問題過後,才能夠合併(Merge)到release分支,並且要更新版本號</strong></li> <li><code>Semantic Versioning</code>(語易化版本規範)<ul> <li>總共會是三位數搭配兩個小數點的版本表示方式, 例如: <code>2.0.0</code></li> <li>三個位數代表的分別是: <code>MAJOR</code>.<code>MINOR</code>.<code>PATCH</code></li> <li><code>MAJOR version</code>: 當我們發布與之前版本**不相容(Incompatibal)** 的API調整</li> <li><code>MINOR version</code>: 當我們新增一個可以**向後兼容規範(backwards compatible manner)** 的功能</li> <li><code>PATCH version</code>: 當我們處理了可以**向後兼容(backwards compatible)** 的故障處理(bug fixes)</li> </ul> </li> <li>可參考<a href=https://semver.org/ >(Semantic Versioning)語易化版本規範</a></li> <li>當如果有多個<code>release version</code>的話，會建立不同版號的<code>release branch</code>，當如果有需要版本的<code>更新檔</code>(patch),會藉由$ <code>git cherry-pick</code>挑選需要的<code>Commit物件</code>到對應的版本分支(<code>release branch</code>)上。 </li> <li><img alt="GitLab Flow流程_Release branches with GitLab flow_官方圖解說明" src=../../assets/pics/git/GitLab%20Flow%E6%B5%81%E7%A8%8B_Release%20branches%20with%20GitLab%20flow_%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems>https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems</a></li> </ul> </li> <li>GitLab Flow 的 <code>Merge Request</code>(MR)介紹</li> <li>在GitLab Flow中,當需要將兩個分支<code>合併</code>(Merge)的時候就可以使用<code>Merge Request</code></li> <li><code>Merge Request</code>可以被當作<code>code review</code>的工具,而且不用另外安裝額外的軟體或是套件<ul> <li>當我們新建一個<code>Merge Request</code>後,可以用 "/cc <a class="magiclink magiclink-github magiclink-mention" href=https://github.com/mark title="GitHub User: mark">@mark</a>" 的方式來標記其他的團隊成員,此時代表該<code>MR</code>尚未完成,但歡迎大家對這次的<code>MR</code>做出回饋(<code>feedback</code>)</li> <li>這時所有的團隊成員都可以針對這次的<code>MR</code>所做的修改做出全部(<code>general</code>)或是局部對某幾行(<code>specific line</code>)的評論(<code>line comments</code>)</li> <li>當被指派收到<code>MR</code>的成員(通常是最了解這個專案程式碼的人 or 該專案的管理者),覺得此次的<code>MR</code>是可以被接受的,就會接受此次的<code>MR</code>,並<code>合併</code>(Merge)到主分支(<code>master分支</code>)</li> <li>但如果被指派收到<code>MR</code>的成員(通常是最了解這個專案程式碼的人 or 該專案的管理者),覺得此次的<code>MR</code>是**不能被接受的**,也可以**拒絕接受此次的MR**,並且**不合併**(Merge)到主分支(<code>master分支</code>)</li> <li><img alt="GitLab Flow流程_Merge/pull requests with GitLab flow_官方圖解說明" src=../../assets/pics/git/GitLab%20Flow%E6%B5%81%E7%A8%8B_Merge%3Apull%20requests%20with%20GitLab%20flow_%E5%AE%98%E6%96%B9%E5%9C%96%E8%A7%A3%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems>https://docs.gitlab.com/ee/topics/gitlab_flow.html#git-flow-and-its-problems</a></li> </ul> </li> <li>在GitLab Flow中,慣例上都會將<code>主分支(master)</code>設定為<code>被保護的分支</code>(protected branch)</li> <li>所以如果我們想要將這次的修改<code>合併</code>(Merge)到<code>主分支(master)</code>的話,就要將<code>MR</code>請求指派(<code>assign</code>)給擁有維護者權限的人(<code>maintainer permissions</code>)</li> <li>關於GitLab 的權限設定可以參考<a href=https://docs.gitlab.com/ee/user/permissions.html>GitLab Permissions</a></li> </ul> <h4 id=git-flow-github-flow-gitlab-flow>Git Flow &amp; GitHub Flow &amp; GitLab Flow 三者的比較<a class=headerlink href=#git-flow-github-flow-gitlab-flow title="Permanent link">&para;</a></h4> <ul> <li><code>Git Flow</code></li> <li>優點 <ul> <li>是一套完整明確且清晰的團隊共同協作流程</li> <li><strong>短期分支</strong>(<code>hotfix</code> &amp; <code>release</code> &amp; <code>feature分支</code>)<strong>是依據"任務"建立的,當任務結束時,就會合併到長期分支</strong>(<code>master</code> &amp; <code>develop分支</code>)</li> </ul> </li> <li>缺點<ul> <li>相對另外兩種工作流程(<code>workflow</code>)來說會比較複雜</li> <li>需頻繁切換分支</li> <li>在現今版本快速更迭的時代,<code>Hotfix</code> &amp; <code>Release分支</code>是幾乎用不到的。因為合併到<code>master分支</code>後如果有<code>bug</code>就直接修復且發布下個版本了,如果還使用這兩個分支,需要**合併回develop和master分支**,但實際上**開發者很常忘記合併回這兩個主分支**</li> </ul> </li> <li>可參考<a href=#git-flow介紹>Git Flow介紹</a> </li> <li><code>GitHub Flow</code></li> <li>優點<ul> <li>適合屬於需要**持續發布**的專案</li> <li>方便結合CI/CD (<code>Continuous integration</code>/<code>Continuous Delivery</code> &amp; <code>Continuous Deployment</code>)</li> <li>相對<code>Git Flow</code>簡單許多</li> </ul> </li> <li>缺點<ul> <li><code>master分支</code>會變得不穩定</li> <li><code>情境說明</code></li> <li>當遇到iOS官方版本更新,而如果審核期間又有新版本要發布的話,這個時候只有一個<code>master主分支</code>就會不夠用,所以還得另外再建一個新分支來維護</li> <li>當<code>master分支</code>合併後如果不發布,會造成<code>線上</code>(production)和<code>master分支的內容</code>不一致</li> </ul> </li> <li>可參考<a href=#github-flow介紹>GitHub Flow介紹</a></li> <li><code>GitLab Flow</code></li> <li>優點<ul> <li><code>GitLab Flow</code> 結合了 <code>Git Flow</code> &amp; <code>GitHub Flow</code>兩者的優點</li> <li>有開發環境上的彈性又有單一主分支的方便</li> <li><code>master分支</code>的分支不夠,於是增加了一個<code>production分支</code>,專門用來發布版本(<code>release</code>)</li> <li>方便結合CI/CD (<code>Continuous integration</code>/<code>Continuous Delivery</code> &amp; <code>Continuous Deployment</code>) </li> </ul> </li> <li>缺點<ul> <li>相較於<code>GitHub Flow</code>來說會比較複雜</li> <li>當<code>prodcution版本</code>需要多個版本(<code>pre-production分支</code>)來維護時,可能會變得如同<code>Git Flow</code>一樣複雜</li> </ul> </li> <li>可參考<a href=#gitlab-flow介紹>GitLab Flow介紹</a></li> <li>三種團隊共同協作的工作流程(workflow)的共同點</li> <li>都是**功能驅動式開發**(<code>Feature-driven development</code>)---以需求為開發的起點,先有需求才有以上那些分支,且開發完後該分支就會被合併到主分支,然後刪除</li> <li><code>Git Flow</code> &amp; <code>GitHub Flow</code> &amp; <code>GitLab Flow</code> 三種工作流程的比較可參考<a href=https://medium.com/@patrickporto/4-branching-workflows-for-git-30d0aaee7bf>4 branching workflows for Git</a></li> </ul> <hr> <h3 id=_11>觀念補充<a class=headerlink href=#_11 title="Permanent link">&para;</a></h3> <blockquote> <p><code>git hash-object</code> - Compute object ID and optionally creates a blob from a file<br></p> </blockquote> <h4 id=terminal>終端機(Terminal)是什麼?<a class=headerlink href=#terminal title="Permanent link">&para;</a></h4> <ul> <li>終端機本身通常不是一部電腦,它本身沒有運算能力,僅用來顯示資料及輸入資料,所有的計算都是在主機上處理的</li> <li>其實終端機就是可以讓使用者輸入指令,來跟電腦進行互動</li> </ul> <h4 id=vim-gitvim>Vim 是Git的預設編輯器,Vim主要常用的兩種模式<a class=headerlink href=#vim-gitvim title="Permanent link">&para;</a></h4> <ul> <li>Normal模式:無法輸入文字,僅能複製,貼上,存檔,離開 動作</li> <li>Insert模式:需要先按下 <code>I or A or O</code> ,才能開始輸入文字</li> <li>在Insert模式下,按<code>esc</code>可退回到Normal模式</li> <li>在Normal模式下,按下<code>:wq!</code> ,代表強制存檔完成後直接關閉這個檔案</li> <li><img alt=Vim圖解操作說明 src=../../assets/pics/git/Vim%E5%9C%96%E8%A7%A3%E6%93%8D%E4%BD%9C%E8%AA%AA%E6%98%8E.png><br> 參考圖片出處<a href=https://gitbook.tw/ >https://gitbook.tw/</a></li> </ul> <h4 id=sha-1>SHA-1(安全散列演算法) 介紹<a class=headerlink href=#sha-1 title="Permanent link">&para;</a></h4> <ul> <li><code>SHA-1</code> (Secure Hash Algorithm 1)是一種雜湊演算法,計算之後的結果通常會以<code>40</code>個<code>16進位</code>的數字方式來呈現</li> <li><code>SHA-1</code>: 該演算法的特性之一就是,當輸入的值相同,就會有相同的輸出值</li> <li>在Git中,所有物件的"編號"的計算,主要都是透過這個演算法算出來的</li> <li>碰撞(collision): 代表輸入兩個不同的值(不同的檔案),卻得到相同的結果(相同的SHA-1值),這種情況稱為碰撞(collision)</li> <li>在Git裡,不同種類的Git物件,<code>SHA-1</code>值的計算方式會有些不同</li> <li>可以利用Git內建的$ <code>git hash-object</code> 指令來幫忙算<code>SHA-1值</code>,也可以得到相同的結果<ul> <li>$ <code>git hash-object</code>: 計算出物件的ID(<code>SHA-1值</code>),並選擇性地從一個指定的檔案,來建立一個Blob物件<ul> <li><code>--stdin</code>: 讀取物件來自標準輸入,而不是來自一個檔案</li> </ul> </li> <li>例如: <code>Blob</code>物件的<code>SHA-1</code>值計算公式為</li> <li><code>blob字樣</code> (若為<code>commit物件</code>,則為<code>commit</code>字樣;若為<code>Tree物件</code>,則改為<code>Tree</code>字樣)</li> <li><code>一個空白字元</code></li> <li><code>輸入內容的長度</code></li> <li><code>Null結束符號</code></li> <li><code>輸入內容</code></li> <li>從上列公式可以看出,第1~5項都沒有跟<code>時間</code>或是<code>亂碼</code>有關的內容,只跟<code>要計算的內容</code>有關</li> <li>但是<code>Commit物件</code>和<code>Tag物件</code>則除外,因為這兩個物件本身就<code>有包括時間</code></li> <li>所以,以<code>Blob物件</code>來說,不管是在什麼時間或不同的電腦上,一樣的輸入值,就會有一樣的內容</li> <li>例如: $ <code>printf "Hello, Hans Tsai" | git hash-object --stdin</code> </li> <li><img alt="git hash-object --stdin可以計算SHA-1的值" src=../../assets/pics/git/git%20hash-object%20--stdin%E5%8F%AF%E4%BB%A5%E8%A8%88%E7%AE%97SHA-1%E7%9A%84%E5%80%BC.png></li> </ul> </li> </ul> <hr> <h3 id=_12>參考資料來源<a class=headerlink href=#_12 title="Permanent link">&para;</a></h3> <h4 id=_13>書籍<a class=headerlink href=#_13 title="Permanent link">&para;</a></h4> <ul> <li><a href=https://gitbook.tw/ >為你自己學Git</a></li> <li><a href=https://git-scm.com/book/en/v2>Pro Git</a></li> </ul> <h4 id=medium>Medium<a class=headerlink href=#medium title="Permanent link">&para;</a></h4> <ul> <li><a href=https://medium.com/@lf2lf2111/%E4%B8%89%E7%A8%AE%E7%89%88%E6%8E%A7%E6%B5%81%E7%A8%8B-29c82f5d4469>三種工作流程: Git Flow &amp; GitHub Flow &amp; GitLab Flow 的介紹</a></li> <li><a href=https://medium.com/@patrickporto/4-branching-workflows-for-git-30d0aaee7bf>4 branching workflows for Git</a></li> </ul> <h4 id=it>iT邦幫忙<a class=headerlink href=#it title="Permanent link">&para;</a></h4> <ul> <li><a href=https://ithelp.ithome.com.tw/users/20072606/ironman/2916>用樂高玩轉 GIT 版本控制</a></li> <li><a href=https://ithelp.ithome.com.tw/users/20004901/ironman/525>30天精通Git版本控管---by 黃保翕(Will 保哥)</a></li> </ul> <h4 id=_14>練習場<a class=headerlink href=#_14 title="Permanent link">&para;</a></h4> <ul> <li><a href=https://gitbook.tw/playground>Git 練習場</a></li> <li><a href=http://onlywei.github.io/explain-git-with-d3/#checkout>Visualizing Git Concepts with D3---可練習基礎Git指令</a></li> </ul> <h4 id=_15>免費線上學習資源<a class=headerlink href=#_15 title="Permanent link">&para;</a></h4> <ul> <li><a href=https://training.github.com/ >GitHub Cheat Sheets --- referenced to Git Official Docs</a></li> <li><a href=https://ndpsoftware.com/git-cheatsheet.html>Visual Git Cheat Sheets --- reference to Git Official Docs</a></li> <li><a href=https://try.github.io/ >Resources to learn Git</a></li> </ul> </article> </div> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg> Back to top </button> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../../programming_language/nodejs/ class="md-footer__link md-footer__link--prev" aria-label="Previous: Node.js" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> Previous </span> <div class=md-ellipsis> Node.js </div> </div> </a> <a href=../../mkdocs_info/mkdocs/ class="md-footer__link md-footer__link--next" aria-label="Next: MkDocs" rel=next> <div class=md-footer__title> <span class=md-footer__direction> Next </span> <div class=md-ellipsis> MkDocs </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2023 ~ Hans Tsai </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://github.com/hans-tsai target=_blank rel=noopener title=github.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../..", "features": ["announce.dismiss", "content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy", "content.tooltips", "navigation.footer", "navigation.indexes", "navigation.sections", "navigation.tabs", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "search.suggest", "toc.follow"], "search": "../../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script> <script src=../../assets/javascripts/bundle.220ee61c.min.js></script> <script src=../../assets/javascripts/custom.a678ee80.min.js></script> </body> </html>